BS模型利用HTTP HTTPS协议
CS模型利用TCP/IP协议

BS模型或CS模型的抽象
#ifndef _SOCKETCLINET_H
#endif _SOCKETCLINET_H

#ifdef __cplusplus //如果用了C++的编译器，用C语言的规范来引用
extern "C" {
#endif

//socket客户端环境初始化
int socketclient_init(void** handle);
//socket客户端报文发送
int socketclient_send(void* handle, unsigned char* buf, int buflen);
//socket客户端报文接收
int socketclient_recv(void* handle, unsigned char* buf, int buflen);
//socket客户端环境释放
int socketclient_destroy(void *hanlde);

//第二套API函数
//socket客户端环境初始化
int socketclient_init2(void** handle);
//socket客户端报文发送
int socketclient_send2(void* handle, unsigned char* buf, int buflen);
//socket客户端报文接收
int socketclient_recv2(void* handle, unsigned char** buf, int* buflen);
//socket客户端环境释放
int socketclient_destroy2(void** hanlde);

#ifdef __cplusplus
}
#endif

#endif

//技术点分析
1级指针
2级指针
void** handle类型封装的概念 业务模型封装的概念


数组做函数参数的退化问题 数组做函数参数时会退化为一个指针
正确的做法是把数组内存首地址和数组的有效长度给被调函数
//void printArray(int a[6],int len)
//void printArray(int a[],int len){
void printArray(int *a,int len){
	int i;
	int len2=0;
	le2=sizeof(a)/sizeof(a[0]);//1
	//在这里，实参的a和形参的a数据类型是不一样的，这里的实参是数组类型，而形参是指针类型
	//因此实参中数组的长度是sizeof(a[0])*sizeof(a)，而形参中指针的长度是4
	//传进来的形参的形式不管是int a[] 还是int a[6] 还是int *a C编译器都会把它当作指针类型
	//编译器之所以这样做是因为如果形参当中的a如果也是数组类型的话，就相当于将实参中的数组中所有的数据都拷贝一份到形参中，无形之中降低了C语言编译期的效率
	//而通过指针类型的形参操作数据是C语言的特点
	//形参写在函数里面和写在函数定义的括号里面是一样的，写在函数定义的括号里面拥有对外的属性
	
	for(i=0;i<len;i++){
		printf("%d",a[i]);
	}
}
void main(){
	int a[]={1,2,3,4,5,6};
	int len=sizeof(a)/sizeof(a[0]);
	
	printArray(a,len);
}

内存四区专题讲座
数据类型是为了方便的表示现实中的事物

类型相同的数据有相同的表示形式、存储格式以及相关的操作

数据类型可以理解为创建对象的模具，是固定内存大小的别名
int a;//告诉C编译期分配4个字节的内存
int b[10];//告诉C编译期分配40个字节的内存

printf("%d",b);//1244972
printf("%d",b+1);//1244976
printf("%d",&b);//1244972
printf("%d",&b+1);//1245012

//b+1 &b+1 结果不一样 b &b所代表的数据类型不一样
//b是数组首元素的地址
//&b是整个数组的地址

//b &b 数组数据类型

//区分数组类型 数组指针 数组类型和数组指针类型的关系 下节课才讲

printf("%d",sizeof(b));//40
printf("%d",sizeof(a));//4

//给数据类型起别名
struct Teacher{
	char name[64];
	int age;
};
void main(){
	int a;
	int b[10];
	
	struct Teacher t1; //通过struct Teacher定义的类型在定义变量时必须通过struct Teacher定义，即struct不可以省略
	t1.age=31;
	
	printf("hello...\n");
}


typedef struct Teacher{
	char name[64];
	int age;
}Teacher;
void main(){
	int a;
	int b[10];
	
	Teacher t1; //通过typedef struct Teacher定义的类型在定义变量时可以省略掉struct
	t1.age=31;
	
	printf("hello...\n");
}

typedef还可以对基本类型重命名
typedef int u32;

//数据类型的封装
void 字面意思是无类型
void * 无类型指针
void * 可以指向任何类型的数据

用法1：数据类型的封装
int initHardEnv(void** handle);
void* memcpy(void* dest,const void* src,size_t len);
void* memset(void* buffer,int c,size_t num);

用法2：void修饰函数返回值和参数，仅表示无
如果函数没有返回值，那么应该将其声明为void型
如果函数没有参数，应该将其声明为void
int function(void){
	return 1;
}

void指针的意义
C语言规定只有相同类型的指针才可以相互赋值
void*指针作为左值用于接收任意类型的指针
void*指针作为右值赋值给其他指针时需要强制类型转换
int* p1=NULL;
char* p2=(char*)malloc(sizeof(char)*20); //malloc返回的是一个void*类型的指针

不存在void类型的变量
C语言没有定义void究竟是多大内存的别名

思考1：
C一维数组 二维数组有数据类型吗？int array[10];
若有，数组类型又如何表达？如何定义？
若没有，请说明原因

思考2：
C语言中，函数可以看作一种数据类型吗？
若可以，请说明原因，并进一步思考：函数这种数据类型能再重定义吗？
若不可以，请说明原因
//实际上函数也是一种数据类型，在5天之后讲回调函数时会提到

变量本质分析
变量概念：既可以读又可以写的内存对象称为变量，若一旦初始化后不能修改的对象则称常量
变量本质：程序通过变量来申请和命名内存空间int a=0;
通过变量名可以访问一个或一段内存空间
(一段连续)内存空间的别名(是一个门牌号)
修改变量有几种方法？
	直接改
	间接改 内存有地址编号，拿到变量对应的地址编号也可以修改变量的值
	内存空间可以再取给别名吗？

数据类型和变量的关系
	通过数据类型定义变量

总结及思考题
	对内存，可读可写
	通过变量往内存读写数据
	不是向变量读写数据，而是向变量所代表的内存空间中写数据
	问：变量跑哪去了？
	思考1：变量三要素(名称 大小 作用域)，变量生命周期？
	思考2：C++编译器是如何管理函数的？包括：
		1 函数
		2 变量之间的关系的？
	重要话题：
		内存四区模型
		函数调用模型

int a;
int b;
char* p;
a=10;

printf("%d",&a); //1245024

//直接操纵内存地址
*((int*)1245024)=200; //让编译器以int*的方式处理1245024这块内存，外面的*意思是拿到这块内存，然后再将200放到这块内存中
==========================
char *p;
{
	p=1245024;//将门牌号赋给指针变量p
	*p=300;//*p代表拿到1245045这块内存空间，然后将300放入这块内存空间中
}

操作系统把C代码分成栈 堆 代码区 全局区
栈：由编译器自动分配释放，存放函数的参数值，局部变量的值
堆：由程序员分配释放
全局区(静态区)：全局变量和静态变量的存储是放在一块儿的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，该区域在程序结束后由操作系统释放
常量区：字符串常量和其他常量的存储位置，程序结束后由操作系统释放
程序代码区：存放函数体的二进制代码

//静态存储区理解
char* getStr1(){
	char* p="abcdefg1";
	return p;
}
char* getStr2(){
	char* p="abcdefg2";
  return p;
}
void main(){
	char* p1=NULL;
	char* p2=NULL;
	p1=getStr1();
	p2=getStr2();
	//打印p1 p2所指向内存空间的数据
	printf("%s",p1);//abcdefg1
	printf("%s",p2);//abcdefg2
	printf("%d",p1);//4282320
	printf("%d",p2);//4282456
	//p1和p2的地址不相同 两个函数返回值不一样时，词法分析后的结果有两个
}

char* getStr1(){
	char* p="abcdefg2";
	return p1;
}
char* getStr2(){
	char* p="abcdefg2";
}
void main(){
	char* p1=NULL;
	char* p2=NULL;
	p1=getStr1();
	p2=getStr2();
	//打印p1 p2所指向内存空间的数据
	printf("%s",p1);//abcdefg1
	printf("%s",p2);//abcdefg2
	printf("%d",p1);//4282320
	printf("%d",p2);//4282320
	//p1和p2的地址不同 两个函数返回值一样时，这是因为词法分析后的结果只有一个
}

=================堆区
char *getMem(int num){
	char *p1=NULL;
	p1=(char*)malloc(sizeof(char)*num);
	if(p1==NULL){
		return NULL;
	}
	return p1;
}
void main(){
	char* tmp=NULL;
	tmp=getMem(10);
	if(tmp==NULL){
		return;
	}
	strcpy(tmp,"111222");//往tmp指向的内存空间拷数据
	printf("%s",tmp);//111222
}

==================栈区
char *getMem2(){
	char buf[64];//临时变量，栈区存放
	strcpy(buf,"123456789");
	printf("%s",buf);//12345678
	return buf;//这里的return是把内存块的首地址返回给tmp了
}
void main(){
	char* tmp=NULL;
	tmp=getMem2();//返回的buf已经被释放了，没法引用，这时程序没有当机已经很不错了
	printf("%s",tmp);//什么都没有
}

安装VAssistX，可以设置一些快速生成代码的快捷键
===================写程序测试栈的生长方式，是开口向上还是开口向上
void main(){
	int a;
	int b;
	printf("%d",&a);//1245044
	printf("%d",&b);//1245048
	//有时&a比&b大，有时&a比&b小，后者是更多的情况
	
	char buf[128];//不管栈开口向上还是向下，buf的内存地址永远是向上的
	//栈是静态编译 在编译器buf所代表的内存空间的标号就定了
}

如果在main函数中调用了函数fa，fa中开辟的栈内存在main中不可以访问，fa中开辟的堆内存在main中可以访问
局部函数中在全局区定义的常量，如"abcdefg"也可以在main函数里面调用

每个应用程序都有一个内存四区


指针变量和它所指向的内存块是两个不同的概念
含义1：给p赋值p=0x1111，只会改变指针变量值，不会改变所指的内容p=p+1 p++
含义2：给*p赋值*p='a'，不会改变指针变量的值，只会改变所指的内存块的值
含义3：左边*p表示给内存赋值 右边*p表示取值
含义4：左边 char* p1
含义5：想要通过指针修改内存中的值时一定要保证所指的内存块能修改

char* getStr(){
	char* tmp=NULL;
	tmp="abcdefg";
	return tmp;
}
void main(){
	char *p=getStr();
	*(p+2)='r';//常量区是不可以修改的，直接会报错
}

指针也是一种数据类型，是指它指向的内存空间的数据类型
int getABC(char *p1);
int getABC(char **p2);
int getABC(char ***p3);
int getABC(char (*p4[30]));
int getABC(char p5[10][30]);
指针做函数参数 形参有多级指针的时候
站在编译器角度，只需要分配4个字节的内存
当我们使用内存的时候，我们才关心指针所指向的内存，是一维的还是二维的
含义1：指针步长根据所指内存空间类型来定

野指针案例
char *p1=(char *)malloc(100);
strcpy(p1,"111222");
if(p1!=NULL){
	free(p1);
	p1=NULL;//这一步一定要加，否则p1就成了野指针，因为我们free掉p1的时候是将其对空间的内存释放了，但是p1这个变量里面还存着某个地址，所以需要手动清空它
	//如果不释放的话，当后面的代码再用if判断p1!=NULL从而去判断是否free(p1)时，依然返回true，此时如果再次调用一次free(p1)的话，就是要释放一块没有被引用的地址，肯定会出问题
	
	//指针变量和它所指向的内存块是两个不同的概念，释放了指针所指的内存空间，但是指针变量本身没有重置，造成释放的时候if(p!=NULL)
	
	//避免方法：定义指针的时候初始化成NULL，释放指针所指的内存空间后把指针重置为NULL
}


void main(){
	char buf[128]; //在栈上分配内存
	int i;
	int j=0;
	
	char* p1=NULL;
	char* p2=NULL; //在堆上分配内存
	
	p1=&buf[0];
	p1=&buf[1];
	p1=&buf[2];
	
	p2=(char*)malloc(100);
	
	for(i=0;i<10;i++){
		p1=p2+i; //p1不断的指向p2所指向的堆内存的各个字节，通过这个例子我们可以得出结论：可以通过开辟堆内存空间来让多个函数共享这一块内存
	}
}
---------------------------------------------向null地址copy数据时报错的问题
void main(){
	char* p1=NULL;//定义p1是一个地址 初始化让p1指向了0x0000这个地址
	
	strcpy(p1,"abcdefg");//将"abcdefg"复制到p1所指向的0x0000地址里面，但是0x0000操作系统正在使用，所以报0x0000地址访问冲突的bug
}
============================================================间接赋值

间接赋值从0级到1级指针
int getFileLen(int *p){
	*p=40;
}
//将变量b写在参数中和写在函数体里面没有任何区别，只不过写在参数中具有对外的属性而已，对外属性也就是可以在函数调用的时候为其赋值
int getFileLen3(int b){
	b=100;
}
void main(){
	int a=10;
	int *p=NULL;
	
	a=20;//直接修改
	p=&a;
	*p=30;//p的值是a的地址，*就是一把钥匙，通过地址找到了一块内存空间 间接的修改了a的值
}




间接赋值从1级指针到2级指针
void main(){
	char *p1=NULL;
	char **p2=NULL;

	p1=0x11;
	p2=0x22;

	//直接修改p1的值
	p1=0x111;

	p2=&p1;

	//间接修改p1的值 p2里面就是p1的地址
	*p2=100;
}




//将上面的间接修改抽成函数
void getMem(char **p2){
	*p2=200;//间接赋值 p2是p1的地址
}
void main(){
	char *p1=NULL;
	char **p2=NULL;

	p2=&p1;
	getMem(&p1);//一级指针p1再取地址就是二级指针
}

//设想一下如果通过一级指针来间接修改指针的话
void getMem2(char *p1){
	p1=800; //这里改的只是p1这个变量本身的值，并没有改变p1指向的内存空间的值，因此getMem2执行完后p1的内存被回收，main函数里面的p1指向的内存里面存储的值该是多少还是多少
}
void main(){
	char *p1=NULL;
	getMem2(p1);//不会成功 因为函数里面的形参在函数运行结束后被回收了
}




//综上所述：间接赋值是指针存在的最大意义
//二级指针的应用：给p1 p2初始化，使其指向对应的内存空间
void getMem3(char **myp1,int *mylen1,char **myp2,int *mylen2){
	int ret=0;
	char *tmp1,*tmp2;	
	
	tmp1=(char *)malloc(100);
	strcpy(tmp1,"112233");
	*mylen1=strlen(tmp1);
	*myp1=tmp1;
	
	tmp2=(char *)malloc(100);
	strcpy(tmp2,"aabbcc");
	*mylen2=strlen(tmp2);
	*myp2=tmp2;
	
	return ret;
}
void main(){
	char *p1=NULL;
	int len1=0;
	char *p2=NULL;
	int len2=0;
	getMem3(&p1,&len1,&p2,&len2);
}

可以通过指针间接赋值的3个条件
int main(){
	//条件1 定义了两个变量
	int a=10;
	int *p=NULL;
	//条件2 建立了关联
	p=&a;
	//条件3 *p
	*p=40;
}

间接赋值的应用场景
void main(){
	//第一种 1 2 3这3个条件写在一个函数中
	//第二种 12 写在一个函数里面 3单独写在另外一个函数里面 =>函数调用
	//第三种 1单独写 23写在一块儿 =>抛砖 在C++里面会有，以后会讲
	
	//第一种
	char from[128];
	char to[128]={0};
	char *p1=from;
	char *p2=to;
	strcpy(from,"12345678");
	while(*p1!='\0'){
		*p2=*p1;
		p2++;
		p1++;
	}
	printf("%s",to);
}

间接赋值推论
用一级指针形参间接修改零级指针(实参)的值
用二级指针形参间接修改一级指针(实参)的值

铁律3：理解指针必须和内存四区概念相结合
主调函数可把堆区 栈区 全局数据内存地址传给被调函数
被调函数只能返回堆区 全局数据区
指针做函数参数，是有输入(在主调用函数中分配内存，给被调用函数使用)和输出(和输入相反)特性的
企业开发中经常看到形参中这样的注释
int getMem(char** myp1/*out*/, int* mylen1/*out*/, char** myp2/*out*/, int* mylen2/*out*/); //注释中的out就是为了标明myp1是输出的指针

铁律4 应用指针必须和函数调用相结合(指针做函数参数)见图
一级指针做输入
	//通常用于将数组或字符串作为参数传进被调函数中进行处理
	int showbuf(char* p)
	int showArray(int* array, int iNum)
一级指针做输出
	int getLen(char* pFileName, int* pFileLen)
二级指针做输入
	int main(int arc, char* arg[])
	int showMatrix(int[3][4], int iLine)
二级指针做输出
	int getData(char** data, int* dataLen);
	int getData_Free(void* data);
	int getData_Free(void** data); //避免野指针
三级指针做输出
	int getFileAllLine(char*** content, int* pLine);
	int getFileAllLine_Free(char*** content, int* pLine);

字符串基本操作
C语言的字符串是以0结尾的字符串
C语言中没有字符串类型 通过字符数组来模拟字符串
字符串的内存分配 可以在堆上 栈上 全局区 很重要!!!
void main(){
	//字符数组初始化
	//不指定长度的 C编译器会自动求出元素的个数
	char buf1[]={'a','b','c','d'};//没有以0结尾 不是字符串 只算是字符数组
	//指定长度
	char buf2[100]={'a','a','a','a'};//没有赋值的都是0
	//char buf3[2]={'a','a','a','a'};//如果初始化的个数大于长度 编译会报错
	
	//字符串来初始化字符数组
	char buf3[]="abcd";//buf3作为字符数组的长度是5，后面会多一个0
	//buf3作为字符串长度是4
	int len=strlen(buf3);//4 得到的是字符串的长度
	int len2=sizeof(buf3);//5 得到的是数组的长度
	//数组是一种数据类型，本质是固定大小内存块的别名
}

void main(){
	int i=0;
	char *p=NULL;
	char buf5[128]="abcdefg";//这个字符串是在全局区存储的
	for(i=0;i<strlen(buf5);i++){
		printf("%c",buf5[i]);
	}
	p=buf5;//buf5代表数组首元素的地址
	for(i=0;i<strlen(buf5);i++){
		printf("%c",*(p+i));
	}
}

//[]和*来访问数组元素没区别
buf5[i] ==> buf5[0+i] ==> *(buf5+i)

buf5是一个常量指针 设计成这样是要保证buf5所指向的内存空间安全释放

字符串一级指针内存模型
void main(){
	char buf[20] = "aaaa"; //为变量buf分配了20个字节大小的内存 字符串"aaaa"是放在了全局区
	char buf2[] = "bbbb"; //为变量buf2分配了5个字节大小的内存 字符串"bbbb"也是放在了全局区
	char *p1 = "111111"; //为变量p1分配了4字节大小内存 字符串"111111"也是放在了全局区
	char *p2 = malloc(100); //为变量p2分配了4字节大小内存 从堆中申请了100个字节内存，让p2指向该内存
	strcpy(p2, "3333"); //将全局区的"3333"拷贝到p2所指向的堆内存中
}

字符串copy函数技术推演
//原来的做法
void main(){
	char a[] = "i am a student";
	char b[100];
	int i;
	
	for(i = 0;*(a + i) != '\0';i++){
		*(b + i) = *(a + i);
	}
	
	//此时字符串a末尾的\0并没有拷贝到b中，因此需要手动拷贝
	b[i] = '\0';
}

//现在的做法
void main(){
	char* from = "aaaa";
	char to[100];
	copy_str(from, to);
}

void copy_str(char* from, char* to){
	for(;*from != '\0'; from++,to++){
		*to = *from;
	}
	*to = '\0';
}
//优化后
void copy_str2(char* from, char* to){
	for(;*from != '\0';){
		//先*to = *from 再to++,from++
		*to++ = *from++;
	}
	*to = '\0';
}
//再次优化
void copy_str3(char* from, char* to){
	// 对于循环的最后一次，*from指向d之后，表达式*to = *from的值不为0，故from、to再自增，此时*from会指向'\0'，再将'\0'赋值给*to，*to = *from的值为0，但是*to已经被赋值为0
	while((*to = *from) != '\0'){
		from++;
		to++;
	}
}
//再次优化
void copy_str4(char* from, char* to){
	while((*to++ = *from++) != '\0');
}
//再次优化
void copy_str5(char* from, char* to){
	//0是假
	while(*to++ = *from++);
}

//最好应该判断一下from和to指向的内存是否合法
void copy_str6(char* from, char* to){
	if(to == NULL || from == NULL){
		return -1;
	}
	while(*to++ = *from++);
}

此时如果在copy_str函数中想printf一下from字符串，发现打印不出来了，这是因为from已经指向'\0'了，因此打印不出来，应该在被调用函数中开两个变量把from和to缓冲一下
void copy_str4(char* from, char* to){
	char* tmpfrom = from;
	char* tmpto = to;
	if(tmpfrom == NULL || tmpto == NULL){
		return -1;
	}
	while(*to++ = *from++);
}
上面的案例说明了我们不能轻易改变形参的值，要通过缓冲变量把形参接过来

指针初始化时如果没有合适的值必须初始化为NULL，指针在用完后也要赋值NULL

项目开发中的字符串模型
strstr-whiledowhile模型
void main(){
	int ncount = 0;
	char* p = "abcd111122abcd33333abcdabcd"; //求字符串abcd出现的次数
	do{
		// 返回字符串p中的字串"abcd"的位置
		p = strstr(p, "abcd");
		if(p != NULL){
			ncount++;
			p += strlen("abcd");
		}else{
			break;
		}
	}while(*p != '\0');
}

//将上述需求封装到函数中(以下代码为自己所写)
void main(){
	char* str = "abcd111122abcd33333abcdabcd";
	char* substr = "abcd";
	int len = 0;
	
	get_substr_times(str, substr, &len);
}
int get_substr_times(char* str, char* substr, int* times){
	char* tmp_str = str;
	char* tmp_substr = substr;
	char* p = NULL;
	if(tmp_str == NULL || tmp_substr == NULL){
		return -1;
	}
	while((p = strstr(tmp_str, tmp_substr)) != NULL){
		*times++;
		p += sizeof(tmp_substr);
		if(*p == '\0'){
			break;
		}
	}
	
	return 0;
}

两头堵模型：两个指针，一个指向字符串开头，另一个指向字符串结尾
求非空格的长度
void main(){
	char *p = "    abcdefg    ";
	int i,j = 0;
	int ncount;
	i = 0;
	j = strlen(p) - 1;
	
	while(isspace(p[i]) && p[i] != '\0'){
		i++;
	}
	
	while(isspace(p[j]) && p[j] != '\0'){
		j--;
	}
	ncount = j - i + 1;
}

封装到函数中：
void getCount(char* str, int* pCount){
	char *p = str;
	int i,j = 0;
	if(str == NULL || pCount == NULL){
		return -1;
	}
	
	i = 0;
	j = strlen(p) - 1;
	
	while(isspace(p[i]) && p[i] != '\0'){
		i++;
	}
	
	while(isspace(p[j]) && p[j] != '\0'){
		j--;
	}
	*pCount = j - i + 1;
}

//去除字符串前后空格
void trimSpace(char* str,char* newStr){
	char *p = str;
	int i,j = 0;
	if(str == NULL || pCount == NULL){
		return -1;
	}
	
	i = 0;
	j = strlen(p) - 1;
	
	while(isspace(p[i]) && p[i] != '\0'){
		i++;
	}
	
	while(isspace(p[j]) && p[j] != '\0'){
		j--;
	}
	strncpy(newStr, str, j - i + 1);
	newStr[j - i + 1] = '\0';
}
//优化：不传newStr
void main(){
	// 由于传进来的字符串"    abcdefg    "存储在全局区，是不可以修改的，因此str在修改的时候报错
	//char* str = "    abcdefg    ";
	// 因此要将内存分配在临时区
	char buf[1024] = "    abcdefg    ";
	trimSpace(str);
}
void trimSpace(char* str){
	char *p = str;
	int i,j = 0;
	if(str == NULL || pCount == NULL){
		return -1;
	}
	
	i = 0;
	j = strlen(p) - 1;
	
	while(isspace(p[i]) && p[i] != '\0'){
		i++;
	}
	
	while(isspace(p[j]) && p[j] != '\0'){
		j--;
	}
	// 由于传进来的字符串"    abcdefg    "存储在全局区，是不可以修改的，因此str在修改的时候报错
	strncpy(str, str + i, j - i + 1);
	newStr[j - i + 1] = '\0';
}

//逆序模型
void main(){
	char buf[] = "abcdefg";
	int length = strlen(buf);
	char* p1 = buf;
	char* p2 = buf + length - 1;
	
	while(p1 < p2){
		char c = *p1;
		*p1 = *p2;
		*p2 = c;
		++p1;
		--p2;
	}
}

//抽到函数中
void main(){
	char buf[] = "abcdefg";
	reverse(buf);
}
int reverse(char* buf){
	// 要先定义
	int length;
	char* p1;
	char* p2;
	
	// 再使用
	length = strlen(buf);
	p1 = buf;
	p2 = buf + length - 1;
	
	while(p1 < p2){
		char c = *p1;
		*p1 = *p2;
		*p2 = c;
		++p1;
		--p2;
	}
}

//翻转字符串的另一种方案：递归
//栈模型是先入后出，因此可以先让各个字符依次入栈，再让各个字符依次出栈即可
//可以将逆序的结果存入全局变量

//递归的重点：
//参数的入栈模型
//函数嵌套调用返回流程
char global_buf[100];
void main(){
	char buf[] = "abcdefg";
	memset(global_buf, 0, sizeof(global_buf));
	reverse(buf);
}
void reverse(char* buf){
	if(buf == NULL){
		return;
	}
	//递归结束的条件
	if(*buf == '\0'){
		return;
	}
	reverse(p + 1);
	//printf("%c", *p);
	//存到全局变量global_buf中
	//strncpy(global_buf, p, 1); //把p所指向的字符串处的后面1个字符拷贝到global_buf中去
	strncat(global_buf, p, 1); //把p所指向的字符串处的后面1个字符拼接到global_buf后面去
}

全局变量在多线程中会遇到问题，因此我们要考虑如何用递归修改一个局部变量
void main(){
	char buf[];
	char mybuf[1024];
	
	buf = "abcdefg";
	mybuf[1024] = {0};
	
	reverse(buf, mybuf);
}
void reverse(char* buf, char* bufresult){
	if(buf == NULL){
		return;
	}
	//递归结束的条件
	if(*buf == '\0'){
		return;
	}
	reverse(p + 1, bufresult);
	strncat(bufresult, p, 1);
}

读取键值对
int getKeyByValue(char* keyvaluebuf, char* keybuf, char* valuebuf){
	int ret = 0;
	char* p = NULL;
	
	if(keyvaluebuf == NULL || keybuf == NULL || valuebuf == NULL){
		return -1;
	}
	
	//1、查找keybuf是不是在母串中
	p = keyvaluebuf; //初始化辅助指针变量
	p = strstr(p, keybuf);
	if(p == NULL){
		return -1;
	}
	//让辅助指针变量重新到达下一次检索的条件
	p = p + strlen(keybuf);
	//2、看有没有=号
	p = strstr(p, "=");
	if(p == NULL){
		return -1;
	}
	//让辅助指针变量重新到达下一次检索的条件
	p = p + strlen("=");
	
	//3、在=号后面去除空格
	ret = trimSpace(p, valuebuf);
	if(ret != 0){
		printf("%d", ret);
		return ret;
	}
	return ret;
}
int main(){
	int ret = 0;
	char buf[1024] = {0};
	char* keyandvalue = "key2 = value2
						 key3 = value3
						 key4 = value4";
	char* key2 = "key2";
	
	ret = getKeyByValue(keyandvalue, key2, buf);
	if(ret != 0){
		printf(ret);
	}
}

一级指针容易犯错误的地方：
1、初始化及在调用时所做的判断
char* buf = NULL;		//这是对buf本身，即指针所处的内存本身进行初始化
char* buf = "abc";		//这是对buf指向的内存空间进行初始化，buf将指向全局区的一块空间
char buf[1024] = {0};	//这是对buf指向的内存空间进行初始化，buf将指向栈区的一块空间
指针传入函数后在使用之前需要先判断其是否合法，需要先判断指针是否为NULL，而不是指针指向的内存空间的值是否为NULL，即以下写法为错误写法：
if(*buf == NULL){
	//...
}
如果buf传进来的是NULL，*NULL直接宕机

2、越界
char* buf[3] = "abc"; //错误
char* buf[4] = "abc"; //正确

二级指针
//求文件中两段话的长度
int getMem(char** p1, int* len1, char** p2, int* len2){
	char* tmp1 = NULL;
	char* tmp2 = NULL;
	tmp1 = (char*)malloc(100);
	if(tmp1 == NULL){
		return -1;
	}
	strcpy(tmp1, "abcdefg");
	*len1 = strlen(tmp1);
	*p1 = tmp1;
	
	tmp2 = (char*)malloc(100);
	if(tmp2 == NULL){
		return -2;
	}
	strcpy(tmp2, "abcdefg");
	*len2 = strlen(tmp1);
	*p2 = tmp2;

	return 0;
}
//为了避免野指针的出现，传入二级指针时释放内存空间后还要把二级指针指向的地址空间的值赋值为NULL
int getMemFree(char** p1){
	char* tmp = NULL;
	if(p1 == NULL){
		return -1;
	}
	tmp = *p1;
	free(*p1);
	*p1 = NULL; //释放完指针变量所指的内存空间之后再将实参修改成NULL
	return 0;
}
//传入一级指针时只需要释放内存空间即可
int getMemFree0(char* p1){
	if(p1 == NULL){
		return -1;
	}
	free(p1);
	//p1 = NULL;	//在此将p1置为NULL没有任何意义，因为p1是一个形参，p1仅仅是栈空间的一个变量，函数调用结束之后p1内存被回收
	return 0;
}
int main(){
	char* p1 = NULL;
	int len1 = 0;
	
	char* p2 = NULL;
	int len2 = 0;
	
	getMem(&p1, &len1, &p2, &len2);
	
	getMemFree(&p1);
	getMemFree(&p2);
	
	//如果采用传入一级指针的方式释放：
	//getMemFree0(p1); //在被调用函数中 把p1所指向的内存释放掉，但是实参p1不能被修改成NULL，因此p1依然是野指针
	//getMemFree0(p2);
	//这样释放完后p1 p2依然是野指针
}

总结：
指针做输出时由被调函数分配内存
指针做输入时由主调函数分配内存


二级指针做输入第一种模型
void main(){
	int i = 0;
	int j = 0;
	int num = 0;
	char* tmp = NULL;

	// 数组 数组中的内一个元素装的是指针 指针数组
	// 注意与char* myArray的区分，char* myArray中的myArray变量存储的是一个字符串的首地址
	// char* myArray[]中的myArray变量存储多个字符串首地址的集合
	char* myArray[] = {"aaa", "ccc", "bbb"};
	
	//打印
	num = sizeof(myArray) / sizeof(myArray[0]);
	for(i = 0; i < num; i++){
		// 以下两种方式打印效果一样
		printf("%s", myArray[i]);
		printf("%s", *(myArray + i));
	}
	
	//排序
	for(i = 0; i < num; i++){
		for(j = i; j < num; j++){
			if(strcmp(myArray[i], myArray[j])){
				// 注意：交换的是数组元素，也就是交换指针的值
				tmp = myArray[i];
				myArray[i] = myArray[j];
				myArray[j] = tmp;			
			}
		}
	}
}

//将上述打印和排序封装成函数
void printMyArray(char** myArray, int num){
	int i = 0;
	for(i = 0; i < num; i++){
		// 以下两种方式打印效果一样
		printf("%s", myArray[i]);
		printf("%s", *(myArray + i));
	}
}

void sortMyArray(char** myArray, int num){
	int i = 0;
	int j = 0;
	char* tmp = NULL;
	for(i = 0; i < num; i++){
		for(j = i; j < num; j++){
			if(strcmp(myArray[i], myArray[j])){
				// 注意：交换的是数组元素，也就是交换指针的值，并不是改变指针指向的值
				tmp = myArray[i];
				myArray[i] = myArray[j];
				myArray[j] = tmp;			
			}
		}
	}
}
void main(){
	int num = 0;
	char* myArray[] = {"aaa", "ccc", "bbb"};
	
	num = sizeof(myArray) / sizeof(myArray[0]);
	
	printMyArray(myArray, num);
	
	sortMyArray(myArray, num);
}

二级指针做输入第二种模型
void main(){
	int i = 0;
	int j = 0;
	int num = 4;
	char tmpBuf[30];
	char myBuf[30];
	char myArray[10][30] = {"aaa", "bbb", "ccc", "ddd"};
	
	// 打印
	for(i = 0; i < num; i++){
		printf("%s", myArray[i]);
	}
	
	//排序
	for(i = 0; i < num; i++){
		for(j = i + 1; j < num; j++){
			if(strcmp(myArray[i], myArray[j]) > 0){
				strcpy(tmpBuf, myArray[i]); //交换的是内存块
				strcpy(myArray[i], myArray[j]);
				strcpy(myArray[j], tmpBuf);
			}
		}
	}
}
// 封装到函数中：
void printMyArray_err(char** myArray, int num){
	int i = 0;
	for(i = 0; i < num; i++){
		printf("%s", *(myArray + i));
	}
}
void printMyArray(char myArray[10][30], int num){
	int i = 0;
	for(i = 0; i < num; i++){
		printf("%s", *(myArray + i));
	}
}
// 交换的是内存块，不是指针的指向
void sortMyArray(char myArray[10][30], int num){
	int i = 0;
	int j = 0;
	char tmpBuf[30];
	
	for(i = 0; i < num; i++){
		for(j = i + 1; j < num; j++){
			if(strcmp(myArray[i], myArray[j]) > 0){
				strcpy(tmpBuf, myArray[i]); //交换的是内存块
				strcpy(myArray[i], myArray[j]);
				strcpy(myArray[j], tmpBuf);
			}
		}
	}
}
void main(){	
	int num = 4;
	char myBuf[30];
	// myArray：编译器只会关心：有10行，每行30列，这就解释了第二种内存模型
	// 多维数组myArray + 1，每加1会往后走30字节，即步长是30字节
	char myArray[10][30] = {"aaa", "bbb", "ccc", "ddd"};	
	
	// 打印 调用了上一种内存模型，会down掉
	// 问题的本质是两种内存模型中的myArray + 1不一样，即指针的步长不一样，指针所指向的内存空间的数据类不一样
	printMyArray_err(myArray, num);
	// 正确
	printMyArray(myArray, num);
	
	// 排序
	sortMyArray(myArray, num);
	
	// 用第一种内存模型求myArray的大小
	{
		// 对二级指针常量len1求大小，相当于求其指向的内存空间的大小――300字节 10行30列
		int len1 = sizeof(myArray);
		// myArray第一个元素是一级指针，相当于求其指向的内存空间（第一个元素）的大小，10行30列，每一行占30字节
		int len2 = sizeof(myArray[0]);
		// 求二维数组有多少行
		int size = len1/len2;
		printf("len1:%d, len2:%d, size:%d", len1, len2, size);
	}
}
二级指针做输入第三种模型
void main(){
	int i = 0;
	int j = 0;
	char** p2 = NULL;
	int num = 5;
	char* tmp;
	char tmpbuf[100];
	p2 = (char**)malloc(sizeof(char*) * num);
	
	for(i = 0; i < num; i++){
		//相当于char buf[100];
		p2[i] = (char*)malloc(sizeof(char) * 100);
		sprintf(p[i], "%d%d%d", i + 1, i + 1, i + 1);
	}
	
	for(i = 0; i < num; i++){
		printf("%s", p2[i]);
	}
	
	// 排序 通过交换指针的方式来排序
	for(i = 0; i < num; i++){
		for(j = i + 1; j < num; j++){
			if(strcmp(p2[i], p2[j]) > 0){
				tmp = p2[i];
				p2[i] = p2[j];
				p2[j] = tmp;
			}
		}
	}
	
	// 排序 通过交换指针指向的内存空间的数据来排序
	for(i = 0; i < num; i++){
		for(j = i; j < num; j++){
			if(strcmp(p2[i], p2[j]) > 0){
				// 老师写的
				strcpy(tmpbuf, p2[i]);
				strcpy(p2[i], p2[j]);
				strcpy(p2[j], tmpbuf);
				
				
				// 我写的
				// *tmpbuf = *p2[i];
				// *p2[i] = *p2[j];
				// *p2[j] = *tmpbuf;
			}
		}
	}
	
	// 释放内层的内存 后申请的先释放
	for(i = 0; i < num; i++){
		if(p2[i] != NULL){
			free(p2[i]);
			p2[i] = NULL;
		}
	}
	
	// 释放外层的内存 先申请的后释放
	if(p2 != NULL){
		free(p2);
	}
}

// 将上述程序改为指针做函数参数的
char** getMem(int num){
	int i = 0;
	char** p2 = NULL;
	p2 = (char**)malloc(sizeof(char*) * num);
	
	if(p2 == NULL){
		return NULL;
	}
	
	for(i = 0; i < num; i++){
		//相当于char buf[100];
		p2[i] = (char*)malloc(sizeof(char) * 100);
		sprintf(p2[i], "%d%d%d", i + 1, i + 1, i + 1);
	}
	
	return p2;
}
void printMyArray03(char** myArray, int num){
	int i = 0;

	for(i = 0; i < num; i++){
		// printf("%s", myArray[i]);
		printf("%s", *(myArray + i));
	}
}
void sortMyArray03(char** p2, int num){}{
	int i = 0;
	int j = 0;
	char* tmp;
	char tmpbuf[100];
	// 排序 通过交换指针的方式来排序
	for(i = 0; i < num; i++){
		for(j = i + 1; j < num; j++){
			if(strcmp(p2[i], p2[j]) > 0){
				tmp = p2[i];
				p2[i] = p2[j];
				p2[j] = tmp;
			}
		}
	}
	
	// 排序 通过交换指针指向的内存空间的数据来排序
	for(i = 0; i < num; i++){
		for(j = i; j < num; j++){
			if(strcmp(p2[i], p2[j]) > 0){
				// 老师写的
				strcpy(tmpbuf, p2[i]);
				strcpy(p2[i], p2[j]);
				strcpy(p2[j], tmpbuf);
				
				
				// 我写的
				// *tmpbuf = *p2[i];
				// *p2[i] = *p2[j];
				// *p2[j] = *tmpbuf;
			}
		}
	}
}
void getMemFree03(char** p2, int num){
	int i = 0;
	// 释放内层的内存 后申请的先释放
	for(i = 0; i < num; i++){
		if(p2[i] != NULL){
			free(p2[i]);
			p2[i] = NULL;
		}
	}
	
	// 释放外层的内存 先申请的后释放
	if(p2 != NULL){
		free(p2);
	}
}
void main(){
	int i = 0;
	int j = 0;
	char** p2 = NULL;
	int num = 5;
	char* tmp;
	char tmpbuf[100];
	
	p2 = getMem(num);
	
	printMyArray03(p2, num);
	
	sortMyArray03(p2, num);
}

三种模型内存表示================================
void main(){
	int i = 0;
	
	// 第一种：指针数组
	char* p1[] = {"123", "456", "789"};
	
	// 第二种：二维数组
	char p2[3][4] = {"123", "456", "789"};
	
	// 第三种：手动分配二维内存
	char** p3 = (char**)malloc(3 * sizeof(char*));
	
	for(i = 0; i < 3; i++){
		p3[i] = (char*)malloc(10 * sizeof(char));
		sprintf(p3[i], "%d%d%d", i, i, i);
	}
}

多级指针======================================
int getMem52(char*** p3, int num){
	int i = 0;
	char** p2 = NULL;
	
	//注：是判断p3，而不是判断p3指向的内存空间的值，即不是判断*p3，*p3是可以为NULL的
	if(p3 == NULL){
		return -1;
	}
	
	p2 = (char**)malloc(sizeof(char*) * num);
	
	if(p2 == NULL){
		return NULL;
	}
	
	for(i = 0; i < num; i++){
		//相当于char buf[100];
		p2[i] = (char*)malloc(sizeof(char) * 100);
		sprintf(p2[i], "%d%d%d", i + 1, i + 1, i + 1);
	}
	
	*p3 = p2;
}
void getMemFree03(char*** p3, int num){
	char** tmp = NULL;
	if(p3 == NULL){
		return -1;
	}
	tmp = *p3;
	for(i = 0; i < num; i++){
		free(tmp[i]);
	}
	free(tmp);
	*p3 = NULL;
}
void main(){
	char** p2 = NULL;
	getMem52(&p2, 3);
	getMemFree(&p2, 3);
}

==============================
有一个字符串符合以下特征："aaa,bbb,ccc,ddd" 要求写一个函数，输出以下结果：
1、以逗号分割字符串，形成二维数组，并把结果输出
2、把二维数组行数运算结果也输出

void main(){
	int i = 0;
	char* str = "aaa,bbb,ccc,ddd,";
	char tmp = ',';
	char myArray[10][30];
	int row;
	int ret = 0;
	
	ret = split(str, tmp, myArray, &row);
	if(ret != 0){
		printf("func split err");
	}
	for(i = 0; i < row; i++){
		printf("%s \n", myArray[i]);
	}
}
// 参数c为分隔符
int split(const char* buf1, char c, char buf2[10][30], int* count){
	char* p = NULL;
	char* pTmp = NULL;
	int tmpCount = 0;
	
	p = buf1;
	pTmp = buf1;
	
	do{
		// 检索符合条件的位置 p后移
		p = strchr(p, c);
		if(p != NULL){
			if(p - pTmp > 0){
				strncpy(buf2[tmpCount], pTmp, p - pTmp);
				buf2[tmpCount][p - pTmp] = '\0';
				tmpCount++;
				pTmp = p = p + 1;
			}
		}else{
			break;
		}
	} while(*p!='\0');
	
	*count = tmpCount;
	return 0;
}

用第三种内存模型求解该问题==================================
// 改变二级指针的值，需要在函数中传入三级指针
int split(const char* buf1, char c, char*** myp3, int* count){
	char* p = NULL;
	char* pTmp = NULL;
	char** myp = NULL;
	int tmpCount = 0;
	int ret = 0;
	
	p = buf1;
	pTmp = buf1;
	
	//第一趟扫描，将第一维的长度存储在tmpCount中
	do{
		// 检索符合条件的位置 p后移
		p = strchr(p, c);
		if(p != NULL){
			if(p - pTmp > 0){
				tmpCount++;
				pTmp = p = p + 1;
			}
		}else{
			break;
		}
	} while(*p!='\0');
	
	*count = tmpCount;
	
	myp = (char**)malloc(tmpCount * (char*));
	
	if(myp == NULL){
		ret = -1;
		printf("func split() err:%d (tmpCount * sizeof(char *))", ret);
		goto END;
		// return -1;
	}
	
	//先把申请来的内存清零，便于判断
	memset(myp, 0, tmpCount * sizeof(char*));
	
	tmpCount = 0;
	p = buf1;
	pTmp = buf1;
	
	do{
		p = strchr(p, c);
		if(p != NULL){
			if(p - pTmp > 0){
				// 加上1是为了给字符串最后的\0留下空间
				int len = p - pTmp + 1;
				myp[tmpCount] = (char*)malloc(len * sizeof(char));
				if(myp[tmpCount] == NULL){
					ret = -1;
					printf("func split() err:%d (malloc(len * sizeof(char))", ret);
					goto END;
					// return -1;
				}
				strncpy(myp[tmpCount], pTmp, p - pTmp);
				myp[tmpCount][p - pTmp] = '\0';
				tmpCount++;
				pTmp = p = p + 1;
			}
		}else{
			break;
		}
	}while(*p!='\0');
	
	
	// 这个函数是一个入口，多个出口（也就是有很多个地方（例如异常的时候）可以return出去），这样一来，有可能在申请下来的内存还没等到最后释放就出错了的时候，那这块申请的内存就永远释放不了了，从而导致了内存泄露，因此在所有的异常处理判断分支中都定位到END就可以统一处理异常，而且异常处理函数应该提出去
	END:
	if(ret != 0){
		FreeMem2(myp, count);
		myp = NULL;
		
		//还可以把myp的地址传进去
		//FreeMem3(&myp, count);
	}else{
		// 成功
		*myp3 = myp;
	}	
	return ret;
}
// 异常处理
void FreeMem2(char** myp, int count){
	int i = 0;
	if(myp == NULL){
		return ret;
	}
	for(i = 0; i < tmpCount; i++){
		if(myp[i] != NULL){
			free(myp[i]);
		}
	}
	if(myp != NULL){
		free(myp);
	}
}
void FreeMem3(char*** p, int count){
	int i = 0;
	char** myp = NULL;
	if(p == NULL){
		return;
	}
	myp = *p;
	if(myp == NULL){
		return;
	}
	for(i = 0; i < count; i++){
		if(myp[i] != NULL){
			free(myp[i]);
		}
	}
	if(myp != NULL){
		free(myp);
	}
	*p = NULL;
}
void main(){
	int ret = 0;
	int i = 0;
	char* p1 = "abcdef,accd";
	char cTem = ',';
	int nCount;
	
	ret = split(p1, cTem, &p, &nCount);
	
	if(ret != 0){
		printf("error");
	}
}


数组类型和多维数组本质
扫盲：
数组首元素地址和数组地址是两个不同的概念
数组名代表数组首元素的地址，它是个常量
	解释如下：变量本质是内存空间的别名，一定义数组就分配内存，内存也就固定了，所以数组在最开始起了名之后不可以修改
数组首元素的地址和数组的地址值相等


基础概念：
void main(){
	int a[] = {1, 2};
	int b[100] = {1, 3};
	int c[200] = {0}; //编译时就已经确定所有的值为0
	// c是数组首元素的地址 c+1 往后走4个字节
	// c语言规定：&c是整个数组的地址 &c+1 往后走200*4个字节
	
	memset(c, 0, sizeof(c)); //显式重置内存块
}

数据类型分为基础、非基础，思考角度应该发生变化
C语言中的数组有自己特定的类型
	数组的类型由元素类型和数组大小共同决定，比如：int array[5]的类型是int[5]

类型的本质是固定大小内存块的别名
void main(){
	typedef int (MyArrayType)[5]; //定义了一个数组数据类型
	
	int i = 0;
	MyArrayType myArray; // 相当于int myArray[5];
	
	for(i = 0; i < 5; i++){
		myArray[i] = i + 1;
	}
	
	// myArray代表数组首元素的地址
	printf("%d %d", myArray, myArray + 1); //1244992 1244996
	// &myArray代表整个数组的地址
	printf("%d %d", &myArray, &myArray + 1); //1244992 1245012
}

数组指针类型
定义数组指针类型方法1：
void main(){
	//回顾指针数组：
	char* myArray[] = {"aaa", "bbb"}; //这是指针数组
	
	// 数组指针时用一个指针来指向一个数组
	typedef int (MyArrayType)[5]; //定义了一个数组数据类型
	
	int i = 0;
	MyArrayType myArray; // 相当于int myArray[5]; 用类型定义变量
	MyArrayType* pArray; // 定义一个指针变量，这个指针变量指向一个数组
	
	int myArray2[5]; //myArray2相当于一级指针
	pArray = &myArray2; //相当于二级指针
	for(i = 0; i < 5; i++){
		(*pArray)[i] = i + 1; //相当于 myArray2[i] = i + 1;
	}
	for(i = 0; i < 5; i++){
		printf((*pArray)[i]);
	}
}


定义数组指针类型方法2：
void main(){
	//定义声明一个数组指针类型
	typedef int (*PArrayType)[5];
	PArrayType pArray; //告诉编译器给我分配一个指针变量
	int i;
	
	int c[5];
	
	pArray = &c;
	
	for(i = 0; i < 5; i++){
		(*pArray)[i] = i + 1;
	}
	
	for(i = 0; i < 5; i++){
		printf((*pArray)[i]);
	}
}


定义数组指针类型方法3：
//前两种方法都是通过类型来定义变量 比较麻烦
void main(){
	int (*pArray)[5]; //直接定义一个指向数组的数组指针变量
	int c[5];
	pArray = &c;
}

多维数组名本质剖析
void main(){
	int a[3][5];
	int i = 0;
	int j = 0;
	int tmp = 1;
	
	for(i = 0; i < 3; i++){
		for(j = 0; j < 5; j++){
			a[i][j] = tmp++;
		}
	}
	
	for(i = 0; i < 3; i++){
		for(j = 0; j < 5; j++){
			printf(a[i][j]);
		}
	}
	
	//多维数组名代表什么意思？
	//a + 1往后走了5 * 4 = 20个字节
	printf(a, a+1); // 1244964 1244984
	//&a + 1往后走了5 * 3 * 4 = 60个字节
	printf(&a, &a+1); // 1244964 1245024
	
	
	{
		//定义一个指向数组的指针变量
		int (*pArray)[5]; //告诉编译器给我分配4个字节的内存（32bit平台下）
		pArray = a;
		for(i = 0; i < 3; i++){
			for(j = 0; j < 5; j++){
				printf(pArray[i][j]); //多维数组名的本质是数组指针
			}
		}
	}
	
	// 对于二维数组a
	// (a + i) 第i行首地址
	// *(a + i) 是一级指针，代表第i行首元素的地址
	// *(a + i) + j 代表第i行第j列的元素的地址，相当于&a[i][j]
}

a[i][j] ==> a[0 + i][j] ==> *(a + i)[j] ==> *(a + i)[0 + j] ==> *(*(a + i) + j)

多维数组做函数参数退化原因
void printArray(int a[3][5]);
void printArray(int a[][5]);
void printArray(int (*a)[5]);

指针数组应用场景

main函数的参数
//char* argv[]其实就是二维数组，即二级指针，也就是char** argv，写成char* argv[]是为了更直观
//main函数由操作系统调用，main函数是操作系统和应用程序沟通的一个桥梁
//之所以写成main，是因为我们和操作系统商量好了，我用main定义入口，操作系统通过读取main进入应用程序
//env是操作系统传给我们的系统配置的所有环境变量的信息

//argv是我们自己往应用程序中传的参数，如果生成了一个a.exe的可执行文件，我们在命令行中执行该程序时，可以带一些参数：a.exe aaa bbb ccc ddd，main函数在调用的时候就会将aaa bbb ccc ddd这四个参数给argv
//argc是我们传入的参数的个数，例如a.exe aaa bbb ccc ddd执行的时候argc就是4
int main(int argc, char* argv[], char**env){}

//指针数组自我结束能力：最后一项给一个0
char* c_keyword1[] = {
	"while",
	"do",
	"for",
	"static",
	'\0'
};
char* c_keyword2[] = {
	"while",
	"do",
	"for",
	"static",
	0
};
char* c_keyword3[] = {
	"while",
	"do",
	"for",
	"static",
	NULL
};

结构体==================================
struct Teacher{
	char name[64];
	int age;
	int id;
}
void main(){
	struct Teacher t1;
}

//类型重定义
typedef struct Teacher{
	char name[64];
	int age;
	int id;
}Teacher
void main(){
	Teacher t1; //用typedef重定义之后struct才可以省略
}

struct Student{
	char name[64];
	int age;
}s1, s2; //定义类型的同时定义变量

struct {
	char name[64];
	int age;
}s3, s4; //匿名类型定义变量

初始化结构体类型的变量=======================
void main(){
	Teacher t1 = {"aaa", 12, 12};
}

定义结构体时初始化
struct Student{
	char name[64];
	int age;
}s1 = {"name", 21};

struct {
	char name[64];
	int age;
}s1 = {"name", 21};

成员引用======================
void main(){
	Teacher t1;
	//点操作符是寻址操作，是age相对于t1的偏移量，在CPU中进行，并没有操作内存
	t1.age = 31;
	strcpy(t1.name, "aaa");
	
	//通过指针操作内存空间
	Teacher* p = NULL;
	p = &t1;
	// ->运算操作也是寻址操作，相对于t1的偏移量，在CPU中进行，并没有操作内存
	printf(p->age);
}

结构体做函数参数=========================
结构体等号操作
void main(){
	Teacher t1 = {"aaaa", 32, 11};
	Teacher t2;
	Teacher t3;
	memset(&t3, 0, sizeof(t3));
	
	t2 = t1;
	
	//编译器给我们提供简单的=赋值操作，我们要顺从
	printf("%s", t2.name); //"aaa"
	printf("%d", t2.age); //32
	
	copyTeacher(t3, t1);
	
	printf("%s", t2.name); //乱码
	printf("%d", t2.age); //乱码
	//拷贝不成功的原因是to的内存空间在copyTeacher函数执行完之后释放，并没有改变t3的值
	
	copyTeacher02(&t3, &t1);
	
	printf("%s", t2.name); //"aaa"
	printf("%d", t2.age); //32
}

void copyTeacher(Teacher to, Teacher from){
	to = from;
}
void copyTeacher02(Teacher* to, Teacher* from){
	*to = *from;
}


结构体数组===================================
typedef struct Teacher{
	char name[64];
	int age;
	int id;
}Teacher;
void printTeacher(Teacher* array, int num){
	int i = 0;
	
	for(i = 0; i < num; i++){
		printf("age", array[i].age);
	}
}
Teacher* createTeacher(int num){
	Teacher* tmp = NULL;
	tmp = (Teacher*)malloc(sizeof(Teacher) * num);
	if(tmp == NULL){
		return NULL;
	}
}
void sortTeacher(Teacher* array, int num){
	int i;
	int j;
	Teacher tmp;
	
	for(i = 0; i < num; i++){
		for(j = i + 1; j < num; j++){
			if(array[i].age > array[j].age){
				tmp = array[i];
				array[i] = array[j];
				array[j] = tmp;
			}
		}
	}
}
void main(){
	Teacher Array[3];
	int i;
	
	for(i = 0; i < 3; i++){
		scanf("%d", &(Array[i].age));
	}
	
	for(i = 0; i < 3; i++){
		printf("%d", Array[i].age);
	}
	
	printTeacher(Array, 3);
	
	sortTeacher(Array, 3);
}
=====================================
Teacher* createTeacher(int num){
	Teacher* tmp = NULL;
	tmp = (Teacher*)malloc(sizeof(Teacher) * num);
	if(tmp == NULL){
		return NULL;
	}
	return tmp;
}
void freeTeacher(Teacher* p){
	if(p != NULL){
		free(p);
	}
}
void main(){
	Teacher* pArray = NULL;
	pArray = createTeacher(3);
	
	for(i = 0; i < 3; i++){
		scanf("%d", &(pArray[i].age));
	}
	
	sortTeacher(pArray, 3);
	
	printTeacher(pArray, 3);
}
====================================
int createTeacher(Teaher** pT, int num){
	Teacher* tmp = NULL;
	tmp = (Teacher*)malloc(sizeof(Teacher) * num);
	if(tmp == NULL){
		return -1;
	}
	*pT = tmp;
	return 0;
}
void freeTeacher(Teacher* p){
	if(p != NULL){
		free(p);
	}
}
void main(){
	int ret = 0;
	Teacher* pArray = NULL;
	ret = createTeacher(&pArray, 3);
	
	if(ret != 0){
		printf("error");
		return ret;
	}
	
	for(i = 0; i < 3; i++){
		scanf("%d", &(pArray[i].age));
	}
	
	sortTeacher(pArray, 3);
	
	printTeacher(pArray, 3);
}
结构体套一级指针=====================
typedef struct Teacher{
	char name[64];
	char* aliasname;
	int age;
	int id;
}Teacher;
int createTeacher(Teaher** pT, int num){
	int i = 0;
	Teacher* tmp = NULL;
	tmp = (Teacher*)malloc(sizeof(Teacher) * num);
	if(tmp == NULL){
		return -1;
	}
	memset(tmp, 0, sizeof(Teacher) * num);
	
	for(i = 0; i < num; i++){
		tmp[i].aliasname = (char*)malloc(60);
	}
	*pT = tmp;
	return 0;
}
void freeTeacher(Teacher* p, int num){
	if(p == NULL){
		return;
	}
	for(i = 0; i < num; i++){
		if(p[i].aliasname != NULL){
			free(p[i].aliasname);
		}
	}
	free(p);
}
void main(){
	int ret = 0;
	Teacher* pArray = NULL;
	ret = createTeacher(&pArray, 3);
	
	
	
	for(i = 0; i < 3; i++){
		scanf("%d", &(pArray[i].age));
		scanf("%d", pArray[i].name); // 向指针所指向的内存空间拷贝数据，char name[64]这种写法就使得结构体在初始化时(Teacher* pArray = NULL;)就已经分配了对应的内存
		scanf("%d", pArray[i].aliasname); // 向指针所指向的内存空间拷贝数据，但前提是这个指针所指向的内存空间得有才可以，char* aliasname只是一个指针，分配了4个字节的空间，并没有分配这个指针指向的内存空间
	}
	
	freeTeacher(pArray, 3);
}
结构体套二级指针=====================
typedef struct Teacher{
	char name[64];
	char* aliasname;
	char** stuame;
	int age;
	int id;
}Teacher;
int createTeacher(Teaher** pT, int num){
	int i = 0;
	int j = 0;
	Teacher* tmp = NULL;
	tmp = (Teacher*)malloc(sizeof(Teacher) * num);
	if(tmp == NULL){
		return -1;
	}
	memset(tmp, 0, sizeof(Teacher) * num);
	
	for(i = 0; i < num; i++){
		char** p;
		tmp[i].aliasname = (char*)malloc(60);
		p = (char**)malloc(3 * sizeof(char*));
		for(j = 0; j < 3; j++){
			p[j] = (char*)malloc(120);
		}
		tmp[i].stuname = p;
	}
	*pT = tmp;
	return 0;
}
void freeTeacher(Teacher* p, int num){
	int i = 0;
	int j = 0;
	if(p == NULL){
		return;
	}
	for(i = 0; i < num; i++){
		if(p[i].aliasname != NULL){
			free(p[i].aliasname);
		}
		
		if(p[i].stuname != NULL){
			char** myp = p[i].stuname;
			for(j = 0; j < 3; j++){
				if(myp[j] != NULL){
					free(myp[j]);
				}
			}
			free(myp);
			p[i].stuname = NULL;
		}
	}
	free(p);
}
void main(){
	int i;
	int j;
	int ret = 0;
	Teacher* pArray = NULL;
	ret = createTeacher(&pArray, 3);
	
	for(i = 0; i < 3; i++){
		scanf("%d", &(pArray[i].age));
		scanf("%d", pArray[i].name);
		scanf("%d", pArray[i].aliasname);
		for(j = 0; j < 3; j++){
			scanf("%s", pArray[i].stuname[j]);
		}
	}
	
	freeTeacher(pArray, 3);
}

综合案例========================================
// 把第一种内存模型第二种内存模型结果copy到第三种内存模型中，并排序，打印
int sort(char** myp1, int num1, char (*myp2)[30], int num2, char*** myp3, int* num3){
	char** p3 = NULL;
	int i = 0;
	int j = 0;
	int k = 0;
	int tmplen = 0;
	char* tmpP = NULL;
	
	p3 = (char**)malloc((num1 + num2) * sizeof(char*));
	if(p3 == NULL){
		return -1;
	}
	
	for(i = 0; i < num1; i++){
		tmplen = strlen(myp1[i]) + 1;
		p3[i] = (char*)malloc(tmplen * sizeof(char));
		if(p3[i] == NULL){
			return -2;
		}
		strcpy(p3[i], myp1[i]);
	}
	
	for(j = 0; j < num2; j++, i++){
		tmplen = strlen(myp2[j]) + 1;
		p3[i] = (char*)malloc(tmplen * sizeof(char));
		if(p3[i] == NULL){
			return -3;
		}
		strcpy(p3[i], myp2[j]);
	}
	
	tmplen = *num3 = num1 + num2;
	//排序
	for(i = 0; i < tmplen; i++){
		for(j = i; j < tmplen; j++){
			if(strcmp(p3[i], p3[j]) > 0){
				tmpP = p3[i];
				p3[i] = p3[j];
				p3[j] = tmpP;
			}
		}
	}
	
	*myp3 = p3;
	
	return ret;
}
int sortFree(char*** myp, int len){
	int i = 0;
	char** p = NULL;
	
	if(myp == NULL){
		return;
	}
	
	p = *myp;
	if(p == NULL){
		return;
	}
	
	for(i = 0; i < len; i++){
		free(p[i]);
	}
	free(p);
	// 只有传入三级指针才可以将二级指针所指向的内存空间清空，从而防止野指针的出现
	*myp = NULL;
}
int main(){
	char* p1[] = {"aaa","aaa","aaa","aaa"};
	char buf2[10][30] = {"111","111","111","111"};
	char** p3 = NULL;
	int len1;	
	int len2;	
	int len3;
	int ret = 0;

	len1 = sizeof(p1)/sizeof(*p1);
	len2 = 3;
	
	ret = sort(p1, len1, buf2, len2, &p3, &len3);
	if(ret != 0){
		printf("error");
		return ret;
	}
	
	for(i = 0; i < len3; i++){
		printf("%s", p3[i]);
	}
}

结构体的深拷贝和浅拷贝=================================
typedef struct Teacher{
	char name[64];
	int age;
	char* pname2;
}Teacher;
void copyTeacher(Teacher* to, Teacher* from){
	//*to = *from;相当于memcpy(to, from, sizeof(Teacher));但是这两种操作都是浅拷贝，不会把指针变量指向的内存空间拷贝过去
	memcpy(to, from, sizeof(Teacher));
}
//深拷贝
void deepCopyTeacher(Teacher* to, Teacher* from){
	*to = *from;
	to->pname2 = (char*)malloc(100);
	strcpy(to->pname2, from->pname2);
}
void main(){
	Teacher t1;
	Teacher t2;
	
	strcpy(t1.name, "name1");
	t1.pname2 = (char*)malloc(100);
	strcpy(t1.pname2, "ssss");
	
	//t1赋给t2
	copyTeacher(&t2, &t1);
	
	if(t1.pname2 != NULL){
		free(t1.pname2);
		t1.pname2 = NULL;
	}
	// 如果是浅拷贝的话，t1和t2这两个变量中存储的地址是一样的，而此时该地址指向的内存空间已经在上面的free(t1.pname2)中释放了，再去free(t2.pname2);就会出问题
	if(t2.pname2 != NULL){
		free(t2.pname2);
		t2.pname2 = NULL;
	}
}

偏移量====================
//一旦结构体定义下来，则结构体中的成员，内存布局就定下来了
//age地址减去64就是结构体的内存地址
typedef struct AdvTeacher{
	char name[64];
	int age;
	int p;
	char* pname2;
}AdvTeacher;
void main(){
	AdvTeacher t1;
	AdvTeacher* p = NULL;
	//还没给p分配内存，直接往p里面拷贝，会down掉
	//strcpy(p1, "dddd");
	p - 1; //p - 1这个操作是在CPU中运算的，并没有操作任何内存 *(p - 1)这个操作才会去取p - 1处指向的内存
	{
		int offsize = (int)&(p->age); //offsize为64，64这个值就是偏移量，偏移了name成员的长度――64字节
	}
	{
		int offsize = (int)&(((AdvTeacher*)0)->age); //64
	}
}


文件操作===============================
按字符读写文件
fputc================
void main(){
	FILE* fp = NULL;
	char* filename = "c:\\1.txt";
	char* filename2 = "c:/1.txt";
	char a[27] = "abcdefg";
	//两种都可以，但是第一种在Linux下不兼容，因此我们通常用第二种
	
	fp = fopen(filename2, "r+");
	if(fp == NULL){
		printf("open fail");
		return;
	}
	printf("open succ");
	for(i = 0; i < strlen(a); i++){
		fputc(a[i], fp);
	}
	fclose(fp);
}

fgetc========================
void main(){
	FILE* fp = NULL;
	char* filename = "c:\\1.txt";
	char* filename2 = "c:/1.txt";
	char a[27] = "abcdefg";
	
	fp = fopen(filename2, "r+");
	if(fp == NULL){
		printf("open fail");
		return;
	}
	printf("open succ");
	
	while(!feof(fp)){
		char tmpc = fgetc(fp);
		printf("%c", tmpc);
	}
	
	if(fp != NULL){
		fclose(fp);
	}	
}

按照行读取文件==================
fputs==================
void main(){
	FILE* fp = NULL;
	char* filename = "c:\\1.txt";
	char* filename2 = "c:/1.txt";
	char a[27] = "abcdefg";
	
	fp = fopen(filename2, "r+");
	if(fp == NULL){
		printf("open fail");
		return;
	}
	printf("open succ");
	fputs(a, fp);
	fclose(fp);
}

fgets========================
void main(){
	FILE* fp = NULL;
	char* filename = "c:\\1.txt";
	char* filename2 = "c:/1.txt";
	char buf[1024];
	
	fp = fopen(filename2, "r+");
	if(fp == NULL){
		printf("open fail");
		return;
	}
	printf("open succ");
	
	while(!feof(fp)){
		// 会把\n也拷贝到buf中
		// 内存打包技术：内存首地址+内存长度
		char* p = fgets(buf, 1024, fp); //C函数库会一行一行的拷贝数据到buf指针所指的内存空间中，并且变成C风格的字符串
		if(p == NULL){
			goto End;
		}
		printf("%s", buf);
	}
End:	
	if(fp != NULL){
		fclose(fp);
	}	
}

按照块的方式操作文件==================
//直接把内存数据写入到文件中
typedef struct Teacher{
	char name[64];
	int age;
}Teacher;
void main(){
	//fwrite======================
	int i = 0;
	FILE* fp = NULL;
	char* fileName = "c:/1.txt";
	Teacher tArray[3];
	int myN = 0;
	
	for(i = 0; i < 3; i++){
		sprintf(tArray[i].name, "%d%d%d", i + 1, i + 1, i + 1);
		tArray[i].age = i + 31;
	}
	
	fp = fopen(fileName, "rb");
	if(fp == NULL){
		printf("error");
	}
	
	for(i = 0; i < 3; i++){
		// 第一个参数是从哪个内存块开始
		// 第二个参数是写多长
		// 第三个参数是写了多少次
		// 第四个参数是将要写入的文件指针
		// 返回值有没有写满磁盘
		myN = fwrite(&tArray[i], sizeof(Teacher), 1, fp);
	}
	
	if(fp != NULL){
		fclose(fp);
	}
	
	
	//fread=======================
	int i = 0;
	FILE* fp = NULL;
	char* fileName = "c:/1.txt";
	Teacher tArray[3];
	int myN = 0;
	
	for(i = 0; i < 3; i++){
		sprintf(tArray[i].name, "%d%d%d", i + 1, i + 1, i + 1);
		tArray[i].age = i + 31;
	}
	
	fp = fopen(fileName, "wb");
	if(fp == NULL){
		printf("error");
	}
	
	for(i = 0; i < 3; i++){
		myN = fread(&tArray[i], sizeof(Teacher), 1, fp);
		//myN = fwrite(&tArray[i], sizeof(Teacher), 1, fp);
	}
	
	for(i = 0; i < 3; i++){
		printf("%s %s", tArray[i].name, tArray[i].age);
	}
	
	if(fp != NULL){
		fclose(fp);
	}	
}

实例：配置文件读写=================================
程序启动时提示
输入1：写配置文件
输入2：读配置文件
输入0：退出

模块划分:
界面（集成测试环境）
接口：读配置文件 写配置文件



项目结构==================================================
cfg_op.h文件==========
#ifndef __CFG_OP_H__
#define __CFG_OP_H__

#ifdef __cplusplus
extern "C" {

//读配置文件
int GetCfgItem(char* pFileName, char* pKey, char* pValue, int* pValueLen);
//写配置文件
int WriteCfgItem(char* pFileName, char* pItemName, char* pItemValue, int itemValueLen);

#ifdef __cplusplus
}
#endif

#endif

cfg_op.c文件===========
#define MaxLine 2048
int GetCfgItem(char* pFileName, char* pKey, char* pValue, int* pValueLen){
	FILE* fp = NULL;
	int ret = 0;
	char* pTmp = NULL;
	char* pBegin = NULL;
	char* pEnd = NULL;
	char lineBuf[MaxLine]; //假设一行数据不会超过2048
	fp = fopen(pFileName, "r");
	if(fp == NULL){
		ret = -1;
		return ret;
	}
	while(!feof(fp)){
		memset(lineBuf, 0, sizeof(lineBuf));
		//一行一行读
		fgets(lineBuf, MaxLine, fp);
		//测试一下：
		//printf("%s", lineBuf);
		
		pTmp = strschr(lineBuf, '=');
		if(pTmp == NULL){
			continue;
		}
		
		//当前循环到的行是否有key
		pTmp = strstr(lineBuf, pKey);
		if(pTmp == NULL){
			continue;
		}
		
		pTmp = pTmp + strlen(pKey);
		//将pTmp指向=前的一个字符
		pTmp = strchr(pTmp, '=');
		if(pTmp == NULL){
			continue;
		}
		//将pTmp指到=的后面
		pTmp = pTmp + 1;
		//测试一下 printf("%s", pTmp);
		
		//拿到value的起点
		while(1){
			if(*pTmp == ' '){
				pTmp++;
			}else{
				pBegin = pTmp;
				if(*pBegin == '\n'){
					//如果是回车，证明这个key没有对应的值
					printf("%s没有对应的值", pKey);
				}
				break;
			}
		}
		
		//拿到value的终点
		while(1){
			if(*pTmp == ' ' || *pTmp == '\n'){
				break;
			}else{
				pTmp = pTmp + 1;
			}
		}
		pEnd = pTmp;
		
		*pValueLen = pEnd - pBegin;
		memcpy(pValue, pBegin, pEnd - pBegin);
		break;
	}
End:
	if(fp != NULL){
		fclose(fp);
	}
	return 0;
}

int WriteCfgItem(char* pFileName, char* pKey, char* pValue, int itemValueLen){
	int rv = 0;
	int iTag = 0;
	int length = 0;
	FILE* fp = NULL;
	char lineBuf[MaxLine];
	char* pTmp = NULL;
	char* pBegin = NULL;
	char* pEnd = NULL;
	char fileBuf[1024 * 8] = {0};
	
	if(pFileName == NULL || pKey == NULL || pValue == NULL){
		rv = -1;
		printf("error");
		goto End;
	}
	
	// 以读写的方式打开文件
	fp = fopen(pFileName, "r+");
	// 如果打开失败了，仅提示一下，后面继续以w+t（如果文件没有就新建一个）的方式再次打开
	if(fp == NULL){
		rv = -2;
		printf("error");
	}
	
	// 如果文件不存在就新建
	if(fp == NULL){
		fp = fopen(pFileName, "w+t");
		if(fp == NULL){
			rv = -3;
			printf("error");
			goto End;
		}
	}
	
	//把文件指针从0位置开始，移动到文件末尾，便于后面通过ftell获取长度
	fseek(fp, 0L, SEEK_END);
	
	//获取文件长度
	length = ftell(fp);
	
	//再将指针指向文件头部
	fseek(fp, 0L, SEEK_SET);
	
	if(length > 1024 * 8){
		rv = -3;
		printf("文件长度太长");
		goto End;
	}
	
	while(!feof(fp)){
		//读每一行
		memset(lineBuf, 0, sizeof(lineBuf));
		pTmp = fgets(lineBuf, MaxLine, fp);
		if(pTmp == NULL){
			break;
		}
		
		//如果当前行有传进来的key，将文件指针移到key处
		pTmp = strstr(lineBuf, pKey);
		if(pTmp == NULL){
			//如果当前行没有传进来的key，copy到filebuf中
			strcat(fileBuf, lineBuf);
		}else{
			//传进来的key在当前行，则替换旧的行，再copy到fileBuf中
			sprintf(lineBuf, "%s=%s\n", pKey, pValue);
			strcat(fileBuf, lineBuf);
			iTag = 1;
		}
	}
	
	if(iTag == 0){
		//如果key不在任何一行中，追加
		fprintf(fp, "%s = %s\n", pKey, pValue);
	}else{
		//如果有key，重新创建文件
		if(fp != NULL){
			fclose(fp);
			fp = NULL; //避免野指针
		}
		fp = fopen(pFileName,"w+t");
		if(fp == NULL){
			rv = -4;
			printf("error");
			goto End;
		}
		fputs(fileBuf, fp);
	}
	
End:
	if(fp != NULL){
		fclose(fp);
	}
	
	return rv;
}

入口文件==================
#include "cfg_op.h"

#define CFGNAME "c:/mycfg.ini";
int TGetCfg(){
	char name[1024] = {0};
	char value[1024] = {0};
	int ret = 0;
	int len = 0;
	
	//从键盘中获取key
	scanf("%s", name);

	ret = GetCfgItem(CFGNAME, name, value, &len);
	if(ret != 0){
		printf("err");
		return ret;
	}
	return 0;
}

int TWriteCfg(){
	char name[1024] = {0};
	char value[1024] = {0};
	int ret = 0;
	
	//从键盘中获取key
	scanf("%s", name);
	scanf("%s", value);

	ret = WriteCfgItem(CFGNAME, name, value, strlen(value));
	if(ret != 0){
		printf("err");
		return ret;
	}
	return 0;
}
void main(){
	int choice;
	for(;;){
		printf("菜单内容。。。略");
		scanf("%d", &choice);
		switch(choice){
			case 1:
				TWriteCfg();
				break;
			case 2:
				TGetCfg();
				break;
			case 0:
				exit(0); //return也可以
				break;
			default:
				exit(0);
		}
	}
}


大文件加密======================================
文件比较大时不可能把整个文件都加载到内存中整体加密
des.h========
#ifndef _OPENDESS_H_
#define _OPENDESS_H_

#ifdef __cplusplus
extern "C" {
#endif

int DescEnc(
	unsigned char* pInData,
	int nInDataLen,
	unsigned char* pOutData,
	int* pOutDataLen
);

int DesDec(
	unsigned char* pInData,
	int nInDataLen,
	unsigned char* pOutData,
	int* pOutDataLen
);

#ifdef __cplusplus
}
#endif

#endif


加密解密测试============
#include "des.h" //引入加密解密库
void main(){
	int ret = 0;
	char* plain = "123456";
	int plainlen = strlen(plain);
	
	char plain2[4096];
	int plainlen2 = strlen(plain2);
	
	unsigned char cryptbuf[4096];
	int cryptlen = 0;
	
	ret = DescEnc(
		plain,
		plainlen,
		cryptbuf,
		&cryptlen
	);
	if(ret != 0){
		printf("error");
	}

	ret = DesDec(
		cryptbuf,
		cryptlen,
		plain2,
		&plainlen2
	);
	if(ret != 0){
		printf("error");
	}
}

入口文件====================
#include "des.h"

int FileSymEnc(const char* pfile1, const char* pfile2){
	FILE* fp1 = NULL;
	FILE* fp2 = NULL;
	unsigned char plainbuf[4096];
	int plainlen = 0;
	int plainlen2 = 0;
	int ret = 0;
	unsigned char cryptbuf[4096];
	int cryptlen = 0;
	
	fp1 = fopen(pfile1, "rb");
	if(fp1 == NULL){
		goto End;
	}
	
	fp1 = fopen(pfile1, "wb");
	if(fp1 == NULL){
		goto End;
	}
	
	while(!feof(fp1)){
		//返回取到的长度
		plainlen = fread(plainbuf, 1, 4096, fp1);
		
		ret = DescEnc(
			plainbuf,
			plainlen,
			cryptbuf,
			&cryptlen
		);
		if(ret != 0){
			printf("error");
			return ret;
		}
		
		//将读到的数据写入fp2所指向的文件中
		plainlen2 = fwrite(cryptbuf, 1, cryptlen, fp2);
		//这里假设明文段和加密段的长度一样
		if(plainlen2 != plainlen){
			ret = -3;
			printf("error: 磁盘已满");
			goto End;
		}
	}
End:
	if(fp1 != NULL){
		fclose(fp1);
	}
	if(fp2 != NULL){
		fclose(fp2);
	}
	
	return 0;
}
void main(){
	const char* file1 = "c:/22.txt";
	const char* file2 = "c:/22enc.txt";
	int ret = 0;
	
	ret = FileSymEnc(file1, file2);
	
	if(ret != 0){
		printf("error");
	}
}

=========================================
socketclient.lib //资源描述文件 描述socketclient.dll
socketclient.dll //动态库 （函数二进制码集合、里面有函数的函数体） 动态库是有规范的 各个操作系统下这个规范是不一样的

动态库测试环境搭建======================
#include "socketclientdll.h"
int main(){
	int ret = 0;
	void* handle = NULL;
	
	unsigned char buf[128];
	int buflen = 3;
	
	unsigned char outbuf[128];
	int outbuflen = 3;
	
	strcpy(buf, "12345");
	
	//客户端初始化，获取handle上下文，cltSocketInit就是调用的动态库里面的方法
	ret = cltSocketInit(&handle);
	if(ret != 0){
		printf("error");
		return ret;
	}
	
	//客户端发报文
	ret = cltSocketSend(handle, buf, buflen);
	if(ret != 0){
		printf("error");
		return ret;
	}
	
	//客户端收报文
	ret = cltSocketRev(handle, outbuf, &outbuflen);
	if(ret != 0){
		printf("error");
		return ret;
	}
	
	//释放客户端资源
	cltSocketDestroy(handle);
}

socketclient动态库====================
typedef struct _SCK_HANDLE{
	char version[64];
	char ip[128];
	int port;
	char *p;
	int plen;
}_SCK_HANDLE; //动态库内部的数据类型，不像让测试程序（上层应用）知道

//通过增加_declspec(dllexport)注解，表明下面的这个方法是该动态库对外开放出去的方法
_declspec(dllexport)
int cltSocketInit(void** handle){
	_SCK_HANDLE *hdl = NULL;
	int ret = 0;
	
	printf("func cltSocketInit() begin");
	hdl = (_SCK_HANDLE*)malloc(sizeof(_SCK_HANDLE));
	if(hdl == NULL){
		ret = -1;
		printf("error");
		return ret;
	}
	memset(hdl, 0, sizeof(_SCK_HANDLE));
	strcpy(hdl->ip, "192.168.1.2");
	hdl->port = 8081;
	*handle = hdl;
	
	printf("func cltSocketInit() end");
	return 0;
}

_declspec(dllexport)
// 客户端发报文
int cltSocketSend(void* handle, unsigned char* buf, int buflen){
	_SCK_HANDLE *hdl = NULL;
	int ret = 0;
	
	hdl = (_SCK_HANDLE*)handle;
	
	hdl->p = (unsigned char*)malloc(buflen* sizeof(unsigned char));
	if(hdl->p){
		ret = -1;
		printf("error");
		return ret;
	}
	memcpy(hdl->p, buf, buflen);
	hdl->plen = buflen;

	return 0;
}

_declspec(dllexport)
int cltSocketRev(void* handle, unsigned char* buf, int buflen){
	_SCK_HANDLE *hdl = NULL;
	int ret = 0;
	
	hdl = (_SCK_HANDLE*)handle;
	
	memcpy(buf, hdl->p, hdl->plen);
	*buflen = hdl->plen;
	
	return 0;
}

_declspec(dllexport)
int cltSocketDestroy(void* handle){
	_SCK_HANDLE *hdl = NULL;
	int ret = 0;
	
	hdl = (_SCK_HANDLE*)handle;
	
	if(hdl->p){
		free(hdl->p);
	}
	free(hdl);
}

==================================
检查内存泄露的工具memwatch.h memwatch.c

win32环境下动态链接库（DLL）编程原理--非重点，有兴趣可以研究下
需要在visual studio中 动态库测试搭建中的链接器里面加入导入的动态库的lib文件，这样程序在链接的时候就可以使用这里面的方法了

visual studio中创建动态库的话需要在开始创建项目时选择dll动态库选项，动态库会生成一个dll和lib文件

===================================
typedef struct Student{
	char name[64];
	int id;
}
typedef struct Teacher{
	char name[64];
	int id;
	char* p;
	char** p2;
	Student s1; //结构体套结构体
	Student* p3; //结构体套指针
	//Teacher t1; //结构体套自身类型的结构体元素，非法，因为结构体的本质就是定义一种数据类型，定义数据类型就需要分配内存空间，而编译器还没给结构体分配完内存空间时又遇到了一个自身类型的结构体，这个成员的大小肯定无法确定，因此非法，但是结构体中可以有自身类型的指针成员
	struct Teacher* pt1; //结构体中可以有自身类型的指针成员
}Teacher;
void main(){
	
}

链表=========================================
typedef struct Teacher{
	int data;
	struct Teacher* next;
}Teacher;
void main(){
	//静态链表：固定节点数，如果放在独立的方法中创建节点的话方法执行完毕节点内存也就释放了
	//动态链表：
	Teacher t1;
	Teacher t2;
	Teacher t3;
	
	t1.data = 1;
	t2.data = 2;
	t3.data = 3;
	
	t1.next = &t2;
	t2.next = &t3;
	t3.next = NULL;
}

============================================
typedef struct Node{
	int data;
	struct Node* next;
}SList;

// 创建链表
SList* SList_Create();

// 遍历链表
int SList_Print(SList* pHead);

// 插入节点
int SList_NodeInsert(SList* pHead, int x, int y);

// 删除节点
int SList_NodeDel(SList* pHead, int y);

// 链表销毁
int SList_Destroy(SList* pHead);

// 创建链表
SList* SList_Create(){
	SList* pHead = NULL;
	SList* pM = NULL;
	SList* pCur = NULL;	
	int data;

	pHead = (SList*)malloc(sizeof(SList));
	if(pHead == NULL){
		return -1;
	}
	pHead->data = 0;
	pHead->next = NULL;
	
	scanf("%d", &data);
	
	pCur = pHead;
	
	while(data != -1){
		pM = (SList*)malloc(sizeof(SList));
		if(pM == NULL){
			return -1;
		}
		pM->data = data;
		pM->next = NULL;
		
		pCur->next = pM;
		pCur = pM;
		
		scanf("%d", &data);
	}
	
	return pHead;
}

// 遍历链表
int SList_Print(SList* pHead){
	SList* pTmp;
	if(pHead == NULL){
		return -1;
	}
	
	pTmp = pHead->next;
	while(pTmp != NULL){
		printf("%d", pTmp->data);
		pTmp = pTmp->next;
	}
	return NULL;
}

// 插入节点
int SList_NodeInsert(SList* pHead, int x, int y){
	SList* pPre = NULL;
	SList* pNext = NULL;
	SList* pCur = NULL;
	SList* pM = NULL; // 即将插入的新节点

	pM = (SList*)malloc(sizeof(SList));
	if(pM == NULL){
		return -1;
	}
	
	pM->next = NULL;
	pM->data = y;
	
	pPre = pHead;
	pCur = pHead->next;
	while(pCur){
		if(pCur->data == x){
			break;
		}
		pPre = pCur;
		pCur = pCur->next;
	}
	
	// 让新节点连接后续链表
	pM->next = pPre->next;
	// 让前驱节点连接新节点
	pPre->next = pM;
	
	return 0;
}

// 删除节点
int SList_NodeDel(SList* pHead, int y){
	SList* pM;
	SList* pCur;
	SList* pPre;
	int data;
	
	pPre = pHead;
	pCur = pHead->next;
	
	while(pCur){
		if(pCur->data == y){
			break;
		}
		pPre = pCur;
		pCur = pCur->next;
	}
	
	if(pCur == NULL){
		printf("没有找到要删除的节点");
		return -1;
	}else{
		pNext->next = pCur->next;
		if(pCur != NULL){
			free(pCur);
		}
	}
	
	return 0;
}

// 链表销毁
int SList_Destroy(SList* pHead){
	SList* tmp = NULL;
	if(pHead == NULL){
		return -1;
	}
	
	tmp = pHead;
	while(pHead != NULL){
		// 注意不可以缓存pHead
		tmp = pHead->next;
		free(pHead);
		pHead = tmp;
	}
	return NULL;
}

// 链表逆置
int SList_Reverse(SList* pHead){
	SList* p; // 前驱指针
	SList* q; // 当前指针
	SList* t; // 当前指针下一个节点
	
	// 排除头结点为空 只有头节点 只有头结点和第二个节点的情况
	if(pHead == NULL || pHead->next == NULL || pHead->next->next == NULL){
		return 0;
	}
	
	// 初始化
	p = pHead->next;
	q = pHead->next->next;
	
	// 从左到右逆置节点
	while(q){
		t = q->next;
		q->next = p;
		p = q;
		q = t;
	}
	
	// 头结点变成尾节点
	pHead->next->next = NULL;
	pHead->next = p;
	
	return 0;
}

void main(){
	int ret = 0;
	SList* pHead = NULL;
	
	// 创建链表
	pHead = SList_Create();
	ret = SList_Print(pHead);
	
	// 向链表中插入节点
	ret = SList_NodeInsert(pHead, 20, 19);
	ret = SList_Print(pHead);
	
	// 删除节点
	ret = SList_NodeDel(pHead, 19);
	ret = SList_Print(pHead);
}

C++============================================================================================================
#include "iostream" // 包含C++的头文件

using namespace std; // 使用命名空间 std 标准的命名空间（在这个命名空间中定义了很多标准定义）

void main(){
	// cout是一个对象 标准输出 相当于黑窗口
	// 左移操作符<<在C++中不仅仅承担了左移的功能，在此作用相当于把"hello..."输出到cout中，这就是C++操作符的重载
	// endl是回车换行
	// 这条语句整体意思是将"hello..."打印到屏幕并且回车换行
	cout << "hello..." << endl;
}

分别用面向过程和面向对象 用C++求圆周长与面积
#include "iostream"
using namespace std;

// 求圆面积
void main(){
	double r = 0;
	double s = 0;
	
	cout << "请输入圆半径:";
	// cin相当于键盘 标准输入
	// 从键盘中输入的数据流入到r变量中
	cin >> r;
	
	s = 3.14 * r * r;
	cout << "圆面积是" << s << endl;
}


面向对象===============
// 定义一个自定义数据类型
struct Circle{
	double m_s; //圆面积
	double m_r; //圆半径
}
// 类似于上面结构体的定义
class MyCircle{
	public:
		double m_s; //圆面积
		double m_r; //圆半径
	public:
		// 成员函数
		void setR(double r){
			m_r = r;
		}
		double getR(){
			return m_r;
		}
		double getS(){
			m_s = 3.14 * m_r * m_r;
			return m_s;
		}
	// protected:
	// private:
}
void main(){
	MyCircle c1, c2, c3; // 用类定义变量
	double r;
	cout << "请输入C1圆的半径:";
	cin >> r;
	// 给c1圆的属性赋值
	c1.setR(r);
	cout << "c1面积" << c1.getS() <<endl;
}


//struct和class的区别：
struct定义的类里面的属性默认是public的，class定义的类里面的属性默认是private的


C++对C的加强：
namespace命名空间加强
iostream中没有引入标准的std 需要我们手工加上using namespace std;否则输出内容需要写成
std::cout << "xxx" << std::endl;

C++标准为了和C区分开，也为了正确使用命名空间，规定头文件不使用后缀.h

实用性增强：变量不必在最开头定义
register关键字加强，C语言中无法取得register变量地址，但C++可以，C++编译器有自己的优化方式，即使不用register关键字也会做优化

变量检测增强：
int a = 1;
int a;
上面的定义C语言是允许的，但是C++不可以

struct类型加强
C语言中定义一个struct结构体，如果在定义时没加typedef，使用该结构体定义变量时必须加上struct关键字，但是C++里面不需要加上struct关键字，struct class这两个关键字完成的功能是一样的，但是二者也有一定区别，在C++的结构体中也可以加上public private等：
struct Teacher{
	public:
}
这样做的功能我们以后再讲

C++中所有变量和函数必须有类型：c语言中不定义函数的参数或返回值类型也是可以的，c++中不可以

新增bool类型关键字，占1个字节bool b1 = 10; C++编译器会将其转为1

三目运算符功能增强
int a = 10;
int b = 20;
(a < b ? a : b) = 30; //在C语言中这行语句编译报错，报表达式不能做左值，也就是说C语言中表达式的返回结果是一个数值，在在C++中表达式返回的是一个变量的本身，因此就可以给它赋值了
要想当做左值，就要让表达式返回一个内存空间，即内存首地址，即指针，可以猜测编译器内部的做法是
*(a < b ? &a : &b) = 30; //这种写法在C语言编译器中也是可以通过的

const=======================================================
const int a;和int const a;是一样的

const int *c; //const修饰指向的内存空间，代表c指向的内存空间不可以修改
int* const d; //const修饰指针，代表d是一个常量指针
const int * const e; //不论是指针本身，还是指针指向的内存空间都不可以修改

int operatorTeacher(const Teacher* pT){
	pT->age = 10; //报错 pT指向的内存空间不可以改
}

int operatorTeacher(Teacher* const pT){
	pT->age = 10; //不报错 pT指向的内存空间可以改
	pT = NULL; //报错 pT本身不可以改
}

int operatorTeacher(const Teacher* const pT){
	pT->age = 10; //报错 pT指向的内存空间不可以改
	pT = NULL; //报错 pT本身不可以改
}

C语言中const是冒牌货
const int a = 10;
int *p;
//a = 1; //报错
p = &a;
*p = 2; //编译可以通过，但是c++中虽然不报错，但是值改不了

C++中const的原理：
编译器碰见常量时，在符号表中放入常量，编译过程中如果发现使用常量，则直接以符号表中的值替换，编译过程中如果发现对const使用了extern或&操作符，则给对应的常量分配存储空间，但不会使用其存储空间中的值：p = (int*)&a;

const分配内存的时机：编译器编译期间

c++中const用来替换#define
int a = 1;
int b = 2;
int array[a + b]; //C、C++编译器都不通过，但在Linux内核里面是成立的，原因是Linux内核的gcc编译器是支持这种写法的

const int a = 1;
const int b = 2;
int array[a + b]; //C++编译中可以通过，而C编译不能通过

C++中的const是由编译器处理的，而C中的#define是由预处理器处理的，仅仅是文本替换
const定义的变量由编译器处理，提供类型检查和作用域检查
void fun1(){
	#define a 10 //这个#define不仅仅对fun1这个函数起作用，会对整个源文件起作用，如果仅仅想将其限制在本函数内使用，需要在函数结束时加上#undef a，#undef不加参数代表把所有的宏定义都卸载掉
	const int b = 20;
	#undef a;
}


引用：C++中引用可以看做已定义变量的别名，类似于js中对象类型变量的引用
int a = 10;
int &b = a; //b就是a的引用
b = 100; //相当于把a修改成了100，a、b都变成了100
a = 200; //a、b都变成了200

引用需要依附于某个变量，定义时必须初始化，否则会报错
// 引用的应用
void myswap(int &a, int &b){
	int c = 0;
	c = a;
	a = b;
	b = c;
}

复杂数据类型引用做函数参数
struct Teacher{
	char name[64];
	int age;
}
void printT(Teacher* pT){
	cout<<pT->age<<endl;
}
// pT是t1的别名，相当于修改了t1
void printT2(Teacher &pT){
	cout<<pT.age<<endl;
}
pT和t1是两个不同的变量
void printT2(Teacher pT){
	cout<<pT.age<<endl;
	pT.age = 45; //不会修改t1.age的值
}
void main(){
	Teacher t1;
	t1.age = 35;
	
	printfT(&t1);
	printfT(t1); //形参pT是t1的别名
	printfT(t1); //t1将其结构体实体拷贝了一份给pT
}

引用的本质
C++编译器背后做了什么工作？
int main(){
	int a = 10;
	int &b = a;
	// b是a的别名，请问C++编译器背后做了什么？
	// 引用在定义的时候必须赋值，因此和常量相似
	
	printf("%d", &a);
	printf("%d", &b); //打印出来的两个值是一样的，证明aheb就是同一块内存空间的门牌号
}
================================================
struct Teacher{
	char name[64]; //占64字节
	int age; //4
	int &a;  //4
	int &b;  //4 引用也占内存空间，很像指针
}
void main(){
	printf("%d", sizeof(Teacher)); //76
}

================================================
引用的本质：常量指针Type& name = Type* const name;
//c++中下面的函数
void func1(int &a){
	a = 5;
}
//会被翻译成
void func2(int* const a){
	*a = 5;
}
void main(){
	int a = 10;
	func2(a);
	printf("%d", a); // 5
	
	func1(&a); //如果是指针，需要程序员手工取实参的地址
}

回忆间接赋值是指针存在的最大意义部分，我们提到了指针使用的三种场合：
//条件1 定义了两个变量
int a=10;
int *p=NULL;
//条件2 建立了关联
p=&a;
//条件3 *p
*p=40;

//第一种 1 2 3这3个条件写在一个函数中
//第二种 12 写在一个函数里面 3单独写在另外一个函数里面 =>函数调用
//第三种 1单独写 23写在一块儿 =>抛砖 在C++里面会有，以后会讲
现在的引用就是第三种使用场合，第二步建立关联部分在C++编译器内部帮我们做了

难点：函数返回值是引用
int getAA1(){
	int a;
	a = 10;
	return a;
}
//返回引用本质上是返回了&a，即返回了a的地址
int& getAA2(){
	int a;
	a = 10;
	return a; //如果是返回栈上的引用，不能成为其它引用的初始值，不能作为左值使用，因此下面用a3来接出错了
}
int* getAA3(){
	int a;
	a = 10;
	return &a;
}
void main(){
	int a1 = 0;
	int a2 = 0;
	// 不可以将常量赋给一个引用
	// int &a3 = 0;
	int &a3;
	
	a1 = getAA1();
	// 当用int型变量接收时，就是把值接过来
	a2 = getAA2();
	// 当用引用型变量接收时，相当于是引用的传递，C++编译器会取*a3的值
	a3 = getAA2();
	
	// debug模式下编译
	printf("%d %d %d",a1,a2,a3); //10 10 乱码
	// release模式下编译
	printf("%d %d %d",a1,a2,a3); //10 10 10
}

==========================================
int j1(){
	static int a = 10;
	a++;
	return a;
}
int& j2(){
	static int a = 10;
	a++;
	return a; //返回静态变量或全局变量时，可以成为其它引用的初始值，既可以作为左值，又可以作为右值
}
void main(){
	int a1;
	int a2;
	
	a1 = j1();
	a2 = j2();
	int& a3 = j2();
	
	printf("%d %d %d",a1,a2,a3); //11 11 12
}

=========================================
//函数当左值
int g1(){
	static int a = 10;
	a++;
	return a;
}
int& g2(){
	static int a = 10;
	a++;
	printf("%d", a);
	return a;
}
void main(){
	g1() = 100; //g1()的返回值是一个具体的值，该值不能作为左值
	g2() = 100; //g2()的返回值是一个变量本身，该值可以作为左值 打印出11
	g2(); //打印出101，第二次执行g2()，前方的static int a = 10;可以忽略
}

指针的引用==========================
#include "iostream"
using namespace std;

struct Teacher{
	char name[64];
	int age;
}
// 在被调用函数中获取资源
int getTeacher(Teacher **p){
	Teacher* tmp = NULL;
	if(p == NULL){
		return -1;
	}
	tmp = (Teacher*)malloc(sizeof(Teacher));
	if(tmp == NULL){
		return -2;
	}
	p->age = 33;
	// p是实参的地址
	*p = tmp;
}

int getTeacher2(Teacher* &myp){
	// 给myp赋值相当于给main函数里面的pT1赋值
	myp = (Teacher*)malloc(sizeof(Teacher));
	if(myp == NULL){
		return -1;
	}
	myp->age = 36;
}

void FreeTeacher(Teacher* pT1){
	if(pT1 == NULL){
		return;
	}
	free(pT1);
}

void main(){
	Teacher *pT1;
	// 通过二级指针赋值
	getTeacher(&pT1);
	// 通过引用赋值
	getTeacher2(pT1);
	FreeTeacher(pT1);
	cout<<pt1->age<<endl;
}

常量引用=======================
引用分为普通引用和常量引用
void main(){
	int x = 20;
	//常引用，常引用的作用是让变量拥有只读属性，不能通过y修改x
	const int& y = x;
	
	//常引用初始化分为两种情况
	//1、用变量初始化常引用
	{
		int x1 = 30;
		const int& y1 = x1; //用x1变量去初始化常引用
	}
	
	//2、用字面量初始化常引用
	{
		const int a = 40; //c++编译器把a放在符号表中
		int& m = 41; //普通引用引用了一个字面量 字面量是没有内存地址的 因此这句话会报错
		// 引用就是给内存取多个门牌号（多个别名）的，41是个常量，直接存在寄存器中，没有地址
		// 如果希望字面量初始化常引用编译通过，需要加上const
		const int& m = 42; //c++编译器会分配内存空间给m
		
	}
}

int& e相当于int* const e; 即常量指针
const int& e相当于const int* const e; 即指针以及指针指向的值都不可以改变

C++对函数的扩展：内联函数
const常量可以替代宏常数定义，如：
const int A = 3; 可以替代 #define A 3

对于宏代码片段，在C++中可以用内联函数来替换，例如：
#define MYFUNC(a, b) ((a) < (b) ? (a) : (b))
可以被替换成
inline int myfunc(int a, int b){
	return a < b ? a : b;
}

C++推荐使用内联函数代替宏代码片段
C++用inline关键字声明内联函数
注：
1、内联函数必须和函数体的实现写在一块
2、C++编译器可以将一个函数进行内联编译，内联函数在最终生成的代码中是没有定义的
	C++编译器直接将函数体插入函数调用的地方（效果类似宏替换）
	内联函数调用时没有普通函数调用时的额外开销（压栈 跳转 返回）
3、C++编译器不一定准许函数的内联请求
4、内联函数是一种特殊的函数，具有普通函数的特征（参数检查 返回类型等）
	内联函数是对编译器的一种请求，因此编译器可能拒绝这种请求
	内联函数由编译器处理，直接将编译后的函数体插入调用的地方
	宏代码片段由预处理器处理，进行简单的文本替换，没有任何编译过程
5、现代C++编译器能够进行编译优化，因此一些函数即使没有inline声明，也可能被编译器内敛编译
	另外，一些现代C++编译器提供了扩展语法，能够对函数进行强制内联
	如：g++中的__attribute__((always_inline))属性
6、C++中内联编译的限制：
	不能存在任何形式的循环语句
	不能存在过多的条件判断语句
	函数体不能过于庞大
	不能对函数进行取址操作
	函数内联声明必须在调用语句之前
	编译器对于内联函数的限制并不是绝对的，内联函数相对于普通函数的优势只是省去了函数调用时的压栈、跳转、返回的开销
	因此，当函数体的执行开销远大于压栈、跳转、返回所用的开销时，那么内联函数将无意义
	
C++支持默认参数，如果某函数既有默认参数，又有非默认参数，则默认参数必须放在最后

//占位参数
void func1(int a, int b, int){

}

func1调用时必须写够3个参数


可以将默认参数和占位参数结合起来，这样做的目的是为以后的程序扩展留下线索，此外还可以兼容C语言程序中可能出现的不规范写法
// 注意第三个参数没有名字，因此函数内部引用不到
void func2(int a, int b, int = 0){
	
}
// 以下两种方式的调用都可以编译通过
func2(1, 2);
func2(1, 2, 3);

C++中的函数重载和别的语言的区别：函数返回值不同不能算作重载


函数重载在本质上是相互独立的不同函数（静态链编）

当由于默认参数而在调用时出现二义性时，编译会失败
int func(int a, int b, int c = 0);
int func(int a, int b);

函数重载和函数指针相结合==============================================
int func(int a){
	return a;
}
int func(int a, int b){
	return a + b;
}
int func(const char* s){
	return strlen(s);
}
//函数指针的定义，本质上就是声明一种函数指针类型

typedef int (*PFUNC)(int a);

typedef int (myTypeFunc)(int a, int b); //myTypeFunc这种函数类型指向传入两个int参数，返回值也是int这种类型的函数

//定义一个函数指针变量
void (*myVarPFunc)(int a, int b);

int main(){
	int c = 0;
	PFUNC p = func;
	
	myTypeFunc* myfuncp = NULL;
	
	c = p(1); //因为传入了1个参数，因此会调用第一个重载
	
	printf("%d", c);
}


C++中类的声明和类的实现是分开的
假如我们定义了一个MyTeacher类
类的声明会被放在头文件中：
#pragma once //只包含一次

class MyTeacher
{
	private:
		int age;
		char name[32];
		
	public:
		void setAge(int age);
		int getAge();
		
}

// #pragma once相当于条件编译宏，上述代码相当于：
#ifndef __MYTEACHER_H_
#define __MYTEACHER_H_

class MyTeacher
{
	xxx
}

#endif


//类的实现放在另一个文件中：
#include "MyTeacher.h"

void MyTeacher::setAge(int out_age){
	age = out_age;
}
int MyTeacher::getAge(){
	return age;
}

//使用该类时：
#include "MyTeacher.h"
void main(){
	MyTeacher t1;
	t1.setAge(36);
}


C++中的构造函数一般来说是自动调用，也可以手动调用
构造函数没有返回值
class Test{
	public:
		Test(){} //无参构造函数
		~Test(){} //析构函数
}

如果Test t1,t2;创建了两个对象，先创建的对象，后销毁，即t2先销毁
===========================
class Test2{
	public:
		Test2(){
			// 此处访问m_a，实际上是访问该类在private中定义的的m_a m_b属性
			m_a = 0;
			m_b = 0;
		}
		Test2(int a){
			m_a = a;
			m_b = 0;
		}
		Test2(int a, int b){
			m_a = a;
			m_b = b;
		}
		Test2(const Test2& a){
			// 赋值构造函数
		}
		int get_m_a(){
			return m_a;
		}
		int get_m_b(){
			return m_b;
		}
	private:
		int m_a;
		int m_b;
}
void f(Test2 ts){
	cout<<ts.get_m_a()<<endl;
}
// g函数在执行Test2 ts(1, 2)时会先执行Test2(int, int)构造函数，紧接着再执行return语句时再执行一次赋值构造函数，赋值构造函数会返回一个匿名对象，g在调用完毕之后变量ts被销毁，g函数调用完毕返回的实际上是这个匿名对象，当调用函数有变量接收该匿名对象时该匿名对象还会存在，否则匿名对象也将被析构
Test2 g(){
	Test2 ts(1, 2);
	return ts;
}
void main(){
	// 构造函数的调用
	// 无参构造函数的调用不需要任何额外的写法：
	Test2 ts1;
	// 实际上Test2 ts1这种形式也可以调用有参构造函数，但是该有参构造函数必须有默认值，即类似下面这种形式：
	// Test2(int a = 1, int b = 2){
	// 	
	// }
	// 但是当类里面有两个以上带默认值的构造函数时，像Test2 ts1这样的方式会报错，因为存在二义性，两个构造函数都有默认值，Test2初始化时不知道该调用哪个构造函数了
	// 调用有参构造函数
	Test2 ts2(1, 2);
	// 这种写法会将(3, 4)当做逗号表达式，最后得到结果是4，调的是有一个参数的构造函数
	// 此处的=将不再是赋值的意义，这里用到了运算符的重载
	Test2 ts3 = (3, 4);
	// 显式调用构造函数完成初始化
	Test2 ts4 = Test2(1, 2); //直接调用构造函数会产生一个匿名对象，匿名对象的去和留（生存周期）是难点
	// 对象初始化和对象赋值是两个不同的概念，这里的对象赋值的等号和上面对象初始化的等号的含义是不一样的
	ts1 = ts4;
	// ===================================
	// 关键看一下赋值构造函数如何调用，总共有4种调用时机
	// 赋值构造函数主要完成用一个对象初始化另外一个对象的功能	
	Test2 ts5(1, 2);
	Test2 ts6(1, 2);
	// 用ts5给ts6赋值 赋值和下面初始化操作是不一样的
	ts6 = ts5;
	// 第一种调用时机：用ts6来初始化ts7，将调用ts7的拷贝构造函数，上面的赋值操作是不会调用构造函数的
	Test2 ts7 = ts6;
	// 第二种调用时机：用ts5初始化ts8对象
	Test2 ts8(ts5);
	// 第三种调用时机：用ts9初始化f的形参，完成形参ts的初始化，再调用其方法
	Test2 ts9(1, 2);
	f(ts9);
	// 第四种调用时机：
	// 若返回匿名对象，赋值给另一个同类型的对象，那么匿名对象在为该对象赋值之后会被析构
	Test2 ts10;
	ts10 = g();
	// 若将返回的匿名对象去初始化另外一个同类型的对象，那么匿名对象会直接转成新的对象，这里明显是把ts11转成了g()返回的匿名对象，从匿名转成有名
	Test2 ts11 = g();
	Test2 ts12(1, 2);
	// 匿名对象赋值给ts12（和g()同类型的对象），匿名对象被析构
	ts12 = g();
}

================================================
// 浅拷贝问题
class Name{
	public:
		Name(const char* myp){
			len = strlen(myp);
			// 因为有\0所以要加1
			my = (char*)malloc(len + 1);
			strcpy(p, myp);
		}
		~Name(){
			if(p != NULL){
				free(p);
				p = NULL;
				len = 0;
			}
		}
	protected:
	private:
		char* p;
		int len;
}
void main(){
	Name obj1("aaaa");
	// 执行到这里时，obj1给obj2赋值，需要用到赋值构造函数，但是Name类中没有赋值构造函数，因此调用编译器默认提供的赋值构造函数，而默认的赋值构造函数是浅拷贝，只是拷贝了一个引用（也就是说仅仅是把p指向的值和len在栈中拷贝了一份，至于p在堆中指向的内存空间并没有被拷贝），在析构obj2时，p指向的内存空间已经被析构了，接下来再析构obj1时，p所指向的内存空间已经被释放，已经成为了一个野指针，就会析构一块已经被释放的内存，因此在main函数执行完毕obj1和obj2在析构的时候就报错了
	Name obj2 = obj1;
}

此时需要手动编写赋值构造函数
class Name{
	public:
		Name(const char* myp){
			len = strlen(myp);
			// 因为有\0所以要加1
			my = (char*)malloc(len + 1);
			strcpy(p, myp);
		}
		Name(const char& obj){
			len = obj.len;
			p = (char*)malloc(len + 1);
			strcpy(p, obj.p);
		}
		~Name(){
			if(p != NULL){
				free(p);
				p = NULL;
				len = 0;
			}
		}
	protected:
	private:
		char* p;
		int len;
}
void main(){
	Name obj1("aaaa");
	Name obj2 = obj1;
	
	Name obj3("bbbb");
	//obj3 = obj1;// 等号操作也是浅拷贝，同样会出现上述问题，这时我们需要显式的重载等号操作符，操作符重载后期会讲到，此外，由于obj3内部malloc的内存没有被free，因此这块内存永远没有被释放，就被泄露了
}

构造函数的初始化列表
class A{
	public:
		A(int _a){
			a = _a;
		}
	private:
		int a;
}

class B{
	public:
	private:
		int b1;
		int b2;
		A a1; //这样写的话找不到对应的初始化构造函数，因此编译不通过
		A a2;
}

void main(){
	A a1(10);
	B objB;
}

通过构造函数列表来解决该问题
class A{
	public:
		A(int _a){
			a = _a;
		}
	private:
		int a;
}

class B{
	public:
		// 构造函数列表
		B(int _b1, int _b2) : a1(1), a2(2){
			
		}
		
		// 构造函数还可以这样写：
		// 即将参数m n传给a1 a2
		B(int _b1, int _b2, int m, int n) : a1(m), a2(n){
			
		}
	private:
		int b1;
		int b2;
		A a1;
		A a2;
}

void main(){
	A a1(10);
	// objB对象在创建的时候，会先执行a1 a2的初始化构造函数，执行顺序遵从构造函数列表里面定义的顺序
	// 析构和构造时的顺序相反
	B objB(1, 2);
	B objB2(1, 2, 3, 4);
}

class MyTest{
	public:
		MyTest(int a, int b, int c){
			this->a = a;
			this->b = b;
			this->c = c;
		}
		MyTest(int a, int b){
			this->a = a;
			this->b = b;
			MyTest(a, b, 100); // 此处调用构造函数时会产生一个匿名对象
		}
		~MyTest{
			printf("%d %d %d", a, b, c); // 1 2 100 匿名对象的c属性确实被改成了100，但匿名对象和t1对象没有任何关系，因此c依然是乱码
		}
	private:
		int a;
		int b;
		int c;
	public:
		int getC() const{return c;}
		void setC(int val) {c = val;}
}
void main(){
	MyTest t1(1, 2);
	printf("%d", t1.getC()); //乱码
}

======================对象的动态创建和销毁（new和delete）====================
new后面跟的类型可以是基础类型 数组类型 自定义的类
class Test{
	public:
		Test int(_a){
			a = _a;
		}
		~Test int(_a){
			
		}
		
	private:
		int a;
}
void main(){
	// c语言中给基础类型分配内存
	int* p = (int*)malloc(sizeof(int));
	*p = 10;
	free(p);
	
	// c++中给基础类型分配内存
	int* p2 = new int;
	*p2 = 20;
	free(p2);
	
	int* p3 = new int(30);
	printf("%d", *p3);
	delete p3;
	
	// c语言中分配数组类型内存
	int *pArray = (int*)malloc(sizeof(int) * 10);
	pArray[0] = 1;
	free(p);
	
	// c++中分配数组类型内存
	int *pArray1 = new int[10];
	pArray1[1] = 2;
	delete [] pArray1; // 释放数组内存时不要忘记加[]
	
	// c语言中分配自定义类型内存
	Test* pT1 = (Test*)malloc(sizeof(Test));
	free(pT1);	
	
	// c++中分配自定义类型内存
	Test* pT2 = new Test(10);
	delete pT2;
	
	// new和delete可以自动调用类里面的构造和析构函数，而malloc和free不可以
	// new和delete是C++的操作符，而malloc和free是C语言中的函数
	// 对于基础类型，malloc出来的内存可以通过delete释放，new出来的内存可以通过free释放
	// 对于数组类型，malloc出来的内存可以通过delete释放，new出来的内存可以通过free释放，该结论仅限数组中盛放基础类型值的情况
	// 对于自定义类型，malloc出来的内存可以通过delete释放，new出来的内存可以通过free释放，但是delete释放malloc时会执行析构函数，free释放new时不会执行析构函数
}

====================静态成员==================
class BB{
	public:
		void printC(){
			cout<<c<<endl;
		}
		void addC(){
			c++;
		}
		static void getC(){
			cout<<c<<endl;
			// 静态方法中不可以调用非静态成员，因为非静态成员是属于某个对象的，在静态方法里使用无法确定它是属于哪个对象的
			// cout<<a<<endl;
		}
	private:
		int a;
		int b;
		static int c;
}
//必须对BB类的静态成员初始化
int BB::c = 10;
void main(){
	BB b1, b2, b3;
	b1.printC(); //10
	b2.addC();
	b1.printC(); //11
	
	// 两种方式调用静态成员
	b3.getC();
	BB::getC();
}

==================================================
C++面向对象模型
class C2{
	public:
		int i;
		int j;
		int k;
		static int m;
	public:
		int getK() const {return k;}
}
void main(){
	printf("%d", sizeof(C2)); //12 静态成员 成员函数不被计算在对象容量中
}

C++编译器对普通成员函数的内部处理：
class Test{
	private:
		int mI;
	public:
		Test(int i){
			mI = i;
		}
		int getI(){
			return mI;
		}
		static void Print(){
			printf("This is class Test.\n");
		}
}
Test a(10);
a.getI();
Test::Print();

上面的代码将被解析为：
struct Test{
	int mI;
}
void Test_initialize(Test* pThis, int i){
	pThis -> mI = i;
}
int Test_getI(Test* pThis){
	return pThis -> mI;
}
void Test_Print(){
	printf("This is class Test.\n");
}
Test a;
Test_initialize(&a, 10);
Test_getI(&a);
Test_Print();

C++函数中成员变量和成员函数是分开存储的
对于成员变量：
	普通成员变量存储于对象中，与struct变量有相同的内存布局和字节对齐方式
	静态成员变量存储于全局数据区中
对于成员函数：
	存储于代码段中
	
由以上结论可以看出：很多对象会共用一块代码，那代码如何区分具体对象呢？
通过上面翻译成的c语言代码来看，发现类中每个方法对应的c语言代码中每个方法里面都有一个pThis指针参数，该参数就代表当前正在调用该方法的对象

// 如果在类中定义一个带有const的方法，以下三种写法都一样
void const OpVar(int a, int b){}
void OpVar(int a, int b) const{}
const void OpVar(int a, int b){}

由于成员方法会被翻译成void OpVar(Test* pThis, int a, int b)，const修饰该函数中的pThis指针，因此实际上被翻译成了void OpVar(const Test* const pThis, int a, int b);

// 返回引用就相当于返回自身
// 当执行t1.TestAdd2(t2)时，this就是&t1，因此返回值实际上是*(&t1)，就是它本身
Test& TestAdd2(Test& t2){
	return *this; // *操作让this回到元素状态
}

========================面向对象实现数组类============================
MyArray.h文件
#pragma once
#include <iostream>
using namespace std;

class Array{
	public:
		Array(int len);
		Array(const Array& obj);
		~Array();
	public:
		void setData(int index, int value);
		int getData(int index);
		int length();
	private:
		int m_length;
		int* m_space;
}

------------------
MyArray.cpp文件
#include "MyArray.h"

Array::Array(int len){
	if (len < 0){
		//m_length = 0;
		//m_space = new int[m_length];
		len = 0;
	}
	
	m_length = len;
	m_space = new int[m_length];
};
Array::Array(const Array& obj){
	this -> m_length = obj.m_length;
	this -> m_space = new int[m_length];
	// 数组中各项复制
	for(int i = 0; i < obj.length(); i++){
		this -> m_space[i] = obj.m_space[i];
	}
};
Array::~Array(){
	if (m_space != NULL) {
		delete [] m_space;
		m_length = 0;
	}
};

void Array::setData(int index, int value){
	m_space[index] = value;
}
int Array::getData(int index){
	return m_space[index];
}
int Array::length(){
	return m_length;
}

------------------
TestArray2.cpp文件
#include <iostream>
#include "Array.h"
using namespace std;
void main(){
	Array a1(10);
	
	for(int i = 0; i < a1.length(); i++){
		a1.setData(i, i);
	}
	
	for(int i = 0; i < a1.length(); i++){
		a1.getData(i);
	}
	
	Array a2 = a1;
	
	for(int i = 0; i < a2.length(); i++){
		a2.setData(i, i);
	}
	
	for(int i = 0; i < a2.length(); i++){
		a2.getData(i);
	}
}


=====================友元函数=====================
在类的外部定义的可以修改类内部的成员
友元函数声明在任何访问修饰符下都可以
class A{
	public:
		friend void modifyA(A* pA);
		A(int a, int b){
			this -> a = a;
			this -> b = b;
		}
	private:
		int a;
		int b;
}
void modifyA(A* pA){
	pA -> a = 100;
}
void main(){
	
}
// Java中将java源文件编译成class字节码文件之后可以通过反射机制分析字节码文件找到类对象，直接修改类的私有属性，于是反射就成了一种标准，c++中的友元函数也是这样的
// 

=====================友元类=====================
class A{
	friend class B; // B类是A类的友元类，即在B类中可以访问A类中的私有成员
	public:
		A(int a = 0, int b = 0){
			this -> a = a;
			this -> b = b;
		}
		int getA(){
			return this -> a;
		}
	private:
		int a;
		int b;
}
class B{
	public:
		void set(int a){
			Aobject.a = 100;
		}
		void printB(){
			cout<<Aobject.a<<endl;
		}
	private:
		A Aobject;
}
void main(){
	B b1;
	b1.set(300);
	b1.printB();
}
若B类是A类的友元类，则B类的所有成员函数都是A类的友元函数
友元类通常涉及为一种对数据操作或类之间传递消息的辅助类

==================运算符重载（语法较复杂）===================
运算符重载使得用户自定义的数据以一种更简洁的方式工作
class Complex{
	public:
		int a;
		int b;
	public:
		Complex(int a = 0, int b = 0){
			this -> a = a;
			this -> b = b;
		}
		void printCom(){
			cout<<a<<endl;
		}
}
// 定义了全局函数
Complex myAdd(Complex &c1, Complex &c2){
	Complex tmp(c1.a + c2.a, c1.b + c2.b);
	return tmp;
}
// 对函数名进行改造
// operator是c++中的关键字
Complex operator+(Complex &c1, Complex &c2){
	Complex tmp(c1.a + c2.a, c1.b + c2.b);
	return tmp;
}
void main(){
	int a = 0;
	int b = 0;
	int c;
	
	c = a + b; // 对于基础数据类型，编译器已经知道如何运算
	
	// c1和c2是两个复数对象
	Complex c1(1, 2), c2(3, 4);
	Complex c3;
	// c3 = c1 + c2;
	// Complex是用户自定义的数据类型，c++编译器是不知道如何进行运算的
	// c++给程序员提供了运算符重载，让自定义数据类型有机会进行运算符操作
	
	// 以下三种写法都一样operator+(c1, c2)和c1 + c2都调到了operator+函数中
	// Complex c4 = myAdd(c1, c2);
	// Complex c4 = operator+(c1, c2);
	// Complex c4 = c1 + c2;
	c4.printCom();
	
	// 运算符重载的本质是函数调用
}

不能重载的运算符： . :: .* ?: sizeof

运算符重载的两种方法：
1、用成员或友元函数重载运算符
成员函数具有this指针，友元函数没有this指针
不管是成员函数还是友元函数重载，运算符的使用方法相同
但传递参数的方式不同，实现代码不同，应用场合也不同

2、通过全局函数重载运算符，上面已经见过了

class Complex{
	private:
		int a;
		int b;
		friend Complex operator+(Complex &c1, Complex &c2);
		friend Complex& operator++(Complex &c1);
		friend Complex operator++(Complex &c1, int);
	public:
		Complex(int a = 0, int b = 0){
			this -> a = a;
			this -> b = b;
		}
		void printCom(){
			cout<<a<<endl;
		}
	public:
		Complex operator-(Complex &c2){
			Complex tmp(this -> a - c2.a, this -> b - c2.b);
			return tmp;
		}
		Complex operator--(int){
			Complex tmp = *this;
			this -> a--;
			this -> b--;
			return tmp;
		}
}
Complex operator+(Complex &c1, Complex &c2){
	// 当a和b是Complex类的私有成员时，像c1.a c1.b这样访问会报错，因此这时需要用到友元函数
	Complex tmp(c1.a + c2.a, c1.b + c2.b);
	return tmp;
}
Complex& operator++(Complex &c1){
	c1.a++;
	c1.b++;
	return c1;
}
// 第二个参数int是一个占位符
Complex operator++(Complex &c1, int){
	// 注意后置++是先使用再++，因此返回的值应该是++之前的值，所以要先将没有++的c1缓存一份，返回的时候把缓存的这份返回出去，这样就能保证它还没++
	Complex tmp = c1;
	c1.a++;
	c1.b++;
	return tmp;
}
void main(){
	Complex c1(1, 2), c2(3, 4);
	Complex c3 = c1 + c2;
	
	// 全局函数实现重载：Complex operator+(Complex &c1, Complex &c2);
	
	// 成员函数实现重载：c1.operator+(c2); => Complex operator+(Complex &c2)
	
	Complex c4 = c1 - c2;
	
	// 注意不论是前置还是后置参数c1的属性都会变化，因此需要传入c1的引用
	// 前置++操作符 用全局函数实现：++c1 => Complex& operator++(Complex &c1); 注意返回类型有&，因此返回的是本身
	
	// 后置++操作符 用全局函数实现：c1++ => Complex operator++(Complex &c1, int);
	// 后置++是先使用，再++，因此返回的应该是一个值
	// 注意我们多了一个参数int，该参数是占位参数，当编译器遇到该参数时会将其解析成后置++
	
	// 成员函数实现后置--
	c1--;
	c1.printCom();
}


左移操作符重载
class Complex{
	public:
		friend void operator<<(ostream &out, Complex &c1);
}
void operator<<(ostream &out, Complex &c1){
	out << c1.a << " " << c1.b << endl;
}
void main(){
	int a = 10;
	Complex c1(1, 2), c2(3, 4);
	cout << a << endl;
	
	// 方法1：通过友元函数实现
	cout << c1;
	
	// 方法2：通过成员函数实现
	// 需要在ostream类中添加成员函数 operator<< 但是ostream类的源码是拿不到的，因此只能使用友元函数的方法来实现运算符重载
	// cout.operator << (c1);
	
	// 如果是目前这种处理方式这里会报错，因为cout << c1的返回值是void，再进行void << "aaa"就会出错
	cout << c1 << "aaa";
}

为了避免cout << c1 << "aaa";执行过程中cout << c1得到void，需要把operator<<的返回值类型改为ostream类
注意友元函数也要跟着变
class Complex{
	public:
		friend ostream& operator<<(ostream &out, Complex &c1);
}
ostream& operator<<(ostream &out, Complex &c1){
	out << c1.a << " " << c1.b << endl;
	return out;
}
void main(){
	int a = 10;
	Complex c1(1, 2), c2(3, 4);
	
	cout << c1 << "aaa";
}

C++规定不能用友元函数重载以下运算符：
= () [] ->

重载等号操作符====================================
回忆之前浅拷贝的问题
// 浅拷贝问题
class Name{
	public:
		Name(const char& myp){
			len = strlen(myp);
			// 因为有\0所以要加1
			my = (char*)malloc(len + 1);
			strcpy(p, myp);
		}
		Name& operator=(Name& obj1){
			// 先把旧的内存释放掉
			if (this -> p != NULL) {
				delete [] p;
				len= 0;
			}
			
			// 根据obj1分配内存大小
			this -> len = obj1.len;
			this -> p = new char [m_len + 1];
			
			strcpy(p, obj1.p);
			// 注意这里的返回值是Name*，也就是Name对象的别名，this不是Name对象，而是指向Name对象的指针
			return *this;
		}
		~Name(){
			if(p != NULL){
				free(p);
				p = NULL;
				len = 0;
			}
		}
	protected:
	private:
		char* p;
		int len;
}
void main(){
	Name obj1("aaaa");
	// 执行到这里时，obj1给obj2赋值，需要用到赋值构造函数，但是Name类中没有赋值构造函数，因此调用编译器默认提供的赋值构造函数，而默认的赋值构造函数是浅拷贝，只是拷贝了一个引用（也就是说仅仅是把p指向的值和len在栈中拷贝了一份，至于p在堆中指向的内存空间并没有被拷贝），在析构obj2时，p指向的内存空间已经被析构了，接下来再析构obj1时，p所指向的内存空间已经被释放，已经成为了一个野指针，就会析构一块已经被释放的内存，因此在main函数执行完毕obj1和obj2在析构的时候就报错了
	Name obj2 = obj1;
	Name obj3("bbb");
	
	obj3 = obj1; // 相应的，这里的赋值也是浅拷贝，析构的时候也会出问题
	
	// 分析：operator=(Name& obj)
}

结论：等号运算符重载的步骤
1、先释放旧的内存
2、根据大小分配内存
3、为内存赋值
4、返回引用

重载数组下标[]操作符======================================
在原来封装的数组类的基础上实现
MyArray.h文件
#pragma once
#include <iostream>
using namespace std;

class Array{
	public:
		Array(int len);
		Array(const Array& obj);
		~Array();
	public:
		void setData(int index, int value);
		int& getData(int index);
		// 只需要返回数组中元素的类型即可
		int operator[](int i);
		Array& operator=(int i);
		Array& operator=(Array& arr);
		bool operator==(Array& arr);
		bool operator!=(Array& arr);
		int length();
	private:
		int m_length;
		int* m_space;
}

------------------
MyArray.cpp文件
#include "MyArray.h"

Array::Array(int len){
	if (len < 0){
		//m_length = 0;
		//m_space = new int[m_length];
		len = 0;
	}
	
	m_length = len;
	m_space = new int[m_length];
};
Array::Array(const Array& obj){
	this -> m_length = obj.m_length;
	this -> m_space = new int[m_length];
	// 数组中各项复制
	for(int i = 0; i < obj.length(); i++){
		this -> m_space[i] = obj.m_space[i];
	}
};
Array::~Array(){
	if (m_space != NULL) {
		delete [] m_space;
		m_length = 0;
	}
};

int& Array::operator[](int i){
	// return this -> getData(i);
	return m_space[i];
}
Array& Array::operator=(int i){
	
}
Array& Array::operator=(Array& arr){
	if (this -> m_space != NULL) {
		delete m_space;
		m_length = 0;
	}
	m_space = new int[arr.m_length];
	m_length = arr.m_length;

	for(int i = 0; i < arr.m_length; i++){
		// 这里的arr[i]直接利用了上面实现的[]的重载
		m_space[i] = arr[i];
	}
	
	return *this;
}
bool Array::operator==(Array& arr){
	if (this -> m_length != arr -> m_length) {
		return false;
	}
	bool isEqual = 1;
	for(int i = 0; i < arr.m_length; i++){
		// 注意这里要写成this->m_space[i]而不是this[i]
		if(this->m_space[i] != arr[i]){
			isEqual = 0;
			break;
		}
	}
	return isEqual;
}
bool Array::operator!=(Array& arr){
	// bool isEqual = 1;
	// for(int i = 0; i < arr.m_length; i++){
	// 	if(this[i] != arr[i]){
	// 		isEqual = 0;
	// 		break;
	// 	}
	// }
	// return !isEqual;
	// 等号操作符上面已经重载了，所以可以直接用
	return !(*this == a1);
}
void Array::setData(int index, int value){
	m_space[index] = value;
}
int Array::getData(int index){
	return m_space[index];
}
int Array::length(){
	return m_length;
}

------------------
TestArray2.cpp文件
#include <iostream>
#include "Array.h"
using namespace std;
void main(){
	Array a1(10);
	
	for(int i = 0; i < a1.length(); i++){
		a1.setData(i, i);
	}
	
	for(int i = 0; i < a1.length(); i++){
		a1.getData(i);
	}
	
	Array a2 = a1;
	
	for(int i = 0; i < a2.length(); i++){
		a2.setData(i, i);
	}
	
	for(int i = 0; i < a2.length(); i++){
		a2.getData(i);
	}
	
	// 对于a1.setData这种写法不像数组赋值
	// 数组赋值应该写成a[i] = i;
	// 这涉及到[]取值运算符和=运算符的重载
	
	// 先看[]运算符的重载
	// 分析：int& operator[](int i) 返回int& 是因为arr[i] = i; 避免arr[i]变成void类型
	// 分析：Array& operator=(int i)
	
	// 数组赋值a1 = a2 = a3也应实现重载
	// 分析：Array& operator=(Array& arr)
	
	// 数组比较a1 == a2、a1 != a2也应实现重载
}

重载括号运算符=================================
F f;
f.getA();
f(5.2, 2.5); // f是一个对象，不是一个函数

class F{
	public:
		int operator()(int a, int b){
			return a * a + b * b;
		}
}
void main(){
	F f;
	f(2, 3); // 在某些开源库如STL中会有这种语法
}

逻辑运算符可以重载，但得不到短路的效果，因此逻辑运算符很少重载

MyString类重载================================
MyString.h
class MyString{
	public:
		MyString(int len = 0);
		MyString(const char* p);
		MyString(const MyString& p);
		~MyString();
	// 运算符重载
	public:
		MyString& operator=(const char* p);
		MyString& operator=(const MyString& s);
		char& operator=(int i);
		friend ostream& operator<<(ostream &out, MyString& s);
		bool operator==(const char* p) const;
		bool operator==(const MyString& s) const;
		bool operator!=(const char* p) const;
		bool operator!=(const MyString& s) const;
		int operator<(const char* p);
		int operator>(const char* p);
		int operator<(MyString& s);
		int operator>(MyString& s);
		friend istream& operator>>(istream& in, MyString& s);
		
	// 把类的指针属性m_p暴露给外部
	public:
		char* c_str(){
			return m_p;
		}
		const char* c_str2(){
			return m_p;
		}
		
	protected:
	private:
		int m_len;
		char* m_p;
}

MyString.cpp
MyString::MyString(int len){
	if (len == 0) {
		m_len = 0;
		// 分配空间
		m_p = new char[m_len + 1];
		// 拷贝数据
		strcpy(m_p, "");
	} else {
		m_len = len;
		m_p = new char[m_len + 1];
		memset(m_p, 0, len);
	}	
}
MyString::MyString(const char* p){
	if (p == NULL) {
		m_len = 0;
		// 分配空间
		m_p = new char[m_len + 1];
		// 拷贝数据
		strcpy(m_p, "");
	} else {
		m_len = strlen(p);
		m_p = new char[m_len];
		strcpy(m_p, p);
	}
}
MyString::MyString(const MyString& s){
	m_len = s.m_len;
	m_p = new char[m_len + 1];
	strcpy(m_p, s.m_p);
}
MyString::~MyString(){
	if (m_p != NULL) {
		delete [] m_p;
		m_p = NULL;
		m_len = 0;
	}
}
// =运算符重载
MyString& MyString::operator=(const char* p){
	// 先释放旧的内存
	if (m_p != NULL) {
		delete [] m_p;
		m_len = 0;
	}
	// 根据新的字符串分配内存
	if (p == NULL) {
		m_len = 0;
		m_p = new char[m_len + 1];
		strcpy(m_p, "");
	} else {
		m_len = strlen(p);
		m_p = new char[m_len + 1];
		strcpy(m_p, p);
	}
	return *this;
}
MyString& MyString::operator=(const MyString& s){
	// 先释放旧的内存
	if (m_p != NULL) {
		delete [] m_p;
		m_len = 0;
	}
	// 根据新的字符串分配内存
	m_len = 0;
	m_p = new char[m_len + 1];
	strcpy(m_p, s.m_p);
	return *this;
}
char& MyString::operator[](int i){
	return m_p[index];
}
ostream& MyString::operator<<(ostream& out, MyString& s){
	out << s.m_p;
	return out;
}
istream& operator>>(istream& in, MyString& s){
	in >> s.m_p;
	return in;
};
bool MyString::operator==(const char* p) const{
	if (p == NULL) {
		return m_len == 0;
	} else {
		if (m_len == strlen(p)){
			// strcmp比较出来，结果是相等就返回0
			return !strcmp(m_p, p);
		} else {
			return false;
		}
	}
};
bool MyString::operator==(const MyString& s) const{
	if (m_len != s.m_len) {
		return false;
	}
	return !strcmp(m_p, s.m_p));
};
bool MyString::operator!=(const char* p) const{
	return !(*this == p);
};
bool MyString::operator!=(const MyString& s) const{
	return !(*this == s);
};
int MyString::operator<(const char* p){
	return strcmp(this -> m_p, p);
};
int MyString::operator>(const char* p){
	return strcmp(p, this -> m_p);
};
int MyString::operator<(MyString& s){
	return strcmp(this -> m_p, s.m_p);
};
int MyString::operator>(MyString& s){
	return strcmp(s.m_p, this -> m_p);
};


MyStringTest.cpp
int main(){
	MyString s1;
	MyString s2("abc");
	MyString s3 = s2;
	MyString s4 = "s44444";
	
	s4 = s2;
	s4 = "s2222";
	
	s4[0];
	
	cout << s4 << endl;
	
	s4 == "abc"
	s4 != "abc"
	s4 == s2;
	s4 != s2;
	
	s4 < "abc"
	s4 > "abc"
	s4 < s2;
	s4 > s2;
	
	cin >> s4;
	cout << s1;
}

继承=====================================
C++继承可以有多重形式
// 通过public方式，继承过来的Parent类里面的各成员访问权限不变
class Child: public Parent{}
// 通过protected方式，继承过来的Parent类里面public成员会成为protected权限
class Child: protected Parent{}
// 通过private方式，继承过来的Parent类里面所有成员会成为private权限
class Child: private Parent{}
总结：继承的方式（public private还是protected）会影响继承过来的成员的访问权限

// 三看原则
看成员在哪里调用（在子类的里面还是外面）
看子类继承父类的方式（是public private还是protected）
看父类成员访问控制权限

类型兼容原则=======================
class Parent{
	public:
		void printP(){
			cout << "父类" << endl;
		}
		Parent(){
			cout << "无参构造函数" << endl;
		}
		Parent(const Parent& obj){
			cout << "赋值构造函数" << endl;
		}
	private:
		int a;
}
class Child: public Parent{
	public:
		void printC(){
			cout << "子类" << endl;
		}
	private:
		int c;
}
void howToPrint(Parent* base){
	base -> printP();
}
void howToPrint2(Parent& base){
	base.printP();
}
int main(){
	Parent p1;
	Child c1;
	
	Parent* p = null;
	// 子类指针或引用可以指向或赋给父类
	p = &c1;
	p -> printP(); // 实际上执行的是子类的方法
	
	// 指针做函数参数
	howToPrint(&p1);
	howToPrint(&c1);
	
	howToPrint(p1);
	howToPrint(c1);
	
	// 可以用子类对象初始化父类对象
	// 此处可以理解为子类就是一种特殊的父类
	// 会调用赋值构造函数
	Parent p3 = c1;
}
===============================
子类对象构造时，需要调用父类构造函数对其继承来的成员进行初始化，且先调用父类构造函数，再调用子类构造函数
子类对象析构时，需要调用父类析构函数对其继承来的成员进行清理，且先调用子类析构函数，再调用父类析构函数
class Parent{
	public:
		void Parent(int a, int b){
			this -> a = a;
			this -> b = b;
			cout << "父类构造函数"
		}
		void printP(){
			cout << "Parnet" << endl;
		}
	private:
		int a;
		int b;
}
class Child: public Parent{
	public:
		// 下面这一行会报错：Parent没有合适的默认构造函数可用
		// 报错的原因是，子类将来实例化的时候会调用父类构造函数，默认调用父类自带的构造函数，但是在这里我们在父类中已经手动写过构造函数了，因此自带的构造函数就会被覆盖，而这样写的话就没有机会调用父类中带两个int参数的构造函数了，这里我们需要改为构造函数初始化列表
		// Child(int c){
		Child(int a, int b, int c): Parent(a, b){
			this -> c = c;
		}
		void printC(){
			cout << "Child" << endl;
		}
	private:
		int c;
}
void main(){
	Parent p;
}

// 对于继承和组合混搭的场合，实例化子类对象会先调用Parent类构造函数，再调用Object类构造函数两次，最后再调用子类自己的构造函数
class Child: public Parent{
	public:
		// 先对父类初始化 在对各个组合对象初始化
		Child(): Parent(p), obj(1), obj(2){
		
		}
	private:
		Object obj1;
		Object obj2;
}

继承中的同名成员可以通过域分辨符::进行同名成员区分（在派生类中使用基类的同名成员，显式地使用类名限定符），同名成员存储在内存中的不同位置
如果不加域分辨符，默认访问的是子类的成员
在外部调用时也可以明确声明：
B b1;
b1.B::b = 1; // 改子类B的b属性
b1.A::b = 2; // 改父类A的b属性

父类定义的静态成员，将被所有子类共享

对于类中的静态成员必须显式的初始化：
class B{
	public:
		static int i;
}
// 这个初始化的作用不仅仅是初始化这个成员，更重要的是告诉编译器要给这个成员分配内存
// 言外之意是不初始化就不会被分配内存
// 如果不分配内存，则无法完成继承
// 如果不初始化虽然可以编译通过，但是一旦在运行过程中使用到了该成员，就会出问题
int B::i = 0;

// 像下面这样写没有加到任何访问修饰符里面，默认是私有的
// 外部实例化对象的时候由于不能访问私有成员，因此肯定实例化不成功
class A{
	A(){}
}

多继承语法：
class A: public B, public C

多继承语法容易产生二义性，已经被其他语言所抛弃
class B{
	public:
		int b;
}
class B1: public B{
	public:
		int b1;
}
class B2: public B{
	public:
		int b2;
}
class C:public B1,public B2{
	public:
		int c;
}
void main(){
	C c1;
	c1.b1 = 100; // ok
	c1.b2 = 200; // ok
	c1.c  = 300; // ok
	c1.b  = 500; // 编译报错对b的访问不明确，因为C继承了B1，也继承了B2，因此从B1那里得到了b属性，也从B2那里得到了b属性，在这里使用的话到底使用的是哪个类的b属性无从得知，为了解决这个问题，C++中引入了虚继承
}

// 引入虚继承，虚继承引入后祖先类B类只执行一次，不加virtual关键字时祖先类B执行了两次
class B{
	public:
		int b;
}
class B1: virtual public B{
	public:
		int b1;
}
class B2: virtual public B{
	public:
		int b2;
}
class C:public B1,public B2{
	public:
		int c;
}
void main(){
	C c1;
	c1.b1 = 100; // ok
	c1.b2 = 200; // ok
	c1.c  = 300; // ok
	c1.b  = 500; // ok
}

虚继承不是重点，虚继承主要用于多态

当子类继承的两个父类中有同名的属性时，子类对象直接访问属性还是无法确定到底是访问哪个类下的属性，这时只能用域分辨符来识别，不可以通过virtual解决

继承父类的时候如果给继承的类加了virtual关键字和不加virtual关键字，占用的内存空间大小是不一样的，加了virtual关键字，C++编译器会给变量偷偷的增加属性，因此会比不加virtual所占的空间大

==================多态
多态是设计模式的基础，是框架设计的基础
封装突破了C语言的概念
继承减少了重复工作，增加了代码复用的功能
多态不仅可以继承原来的代码，还可以复用将来的代码

// 在没有实现多态之前，如下案例：
void main(){
	Parent* base = NULL;
	Parent p1(20);
	Child c1(30);
	
	base = &p1;
	base -> print(); // 20
	
	base = &c1;
	base -> print(); // 虽然我们期望输出30，但是实际输出的是20
	
	Parent& base2 = p1;
	base2.print(); // 20
	
	Parent& base3 = c1;
	base3.print(); // 虽然我们期望输出30，但是实际输出的是20
}

要想实现给父类赋哪个子类就执行哪个子类对应的和父类同名的方法，需要给父类的该方法加virtual关键字，然后子类加不加virtual关键字都可以

实现多态的三个条件：
继承
虚函数重写
父类指针（父类引用）指向子类对象

一个方法如果没有virtual关键字时是静态链接，在编译器编译阶段就知道该怎么执行了，会根据传入的类型执行对应的方法
一个方法如果拥有virtual关键字时是动态链接，在编译器编译阶段不知道该怎么执行，而是推迟到执行的时候确定执行哪个对象的方法

虚析构函数==================
class A{
	public:
		A(){
			p = new char[20];
			strcpy(p, "obja");
		}
		// 想通过父类指针把所有子类对象的析构函数都执行一遍，即想通过父类指针析构所有资源，需要用virtual访问~A()函数
		virtual ~A(){
			delete [] p;
		}
	private:
		char* p;
}
class B: public A{
	public:
		B(){
			p = new char[20];
			strcpy(p, "obja");
		}
		~B(){
			delete [] p;
		}
	private:
		char* p;
}
class C: public B{
	public:
		C(){
			p = new char[20];
			strcpy(p, "obja");
		}
		~C(){
			delete [] p;
		}
	private:
		char* p;
}
// 在最后只执行了~A()析构函数，B和C的析构函数没有执行
// 想通过父类指针把所有子类对象的析构函数都执行一遍，即想通过父类指针析构所有资源，需要用virtual访问~A()函数
void howtodelete(A* base){
	delete base; // 这句话不会表现成多态
}
void main(){
	C *myc = new C;
	
	// 不用virtual关键字，在这里手动调用delete myc;也可以释放A B C内存
	// delete myc;
	
	howtodelete(myc);
}

重载重写重定义====================
重载是在编译期间根据参数类型和个数决定函数调用
重写发生在父类和子类之间，并且父类与子类中的函数必须有完全相同的原型，使用virtual声明之后能够产生多态（如果不用virtual那叫重定义），多态是在运行期间根据具体对象的类型决定函数调用
class Parent{
	public:
		virtual int func(){}
		virtual int func(int i){}
		virtual int func(int i, int j){}
}
class Child: public Parent{
	public:
		// 在父类中也有一个返回值为int，接收两个参数，两个参数类型也是int的方法（即函数模型一样），那么子类中的该方法将重写父类中的对应方法，对于虚方法的重写可以实现多态
		virtual int func(int i, int j){}
		virtual int func(int i, int j, int k){}
}
void main(){
	Child c1;
	// 重载是发生在一个类里面的，子类无法重载父类的函数，父类同名函数将被名称覆盖，子类中只要有一个名字和父类名字相同的方法，父类中的方法就被覆盖了
	// 编译器看到func这个名字在子类中已经存在了，所以编译器不会去父类中找没有参数的func函数
	// 编译器只会在子类中查找func函数，结果找到了两个func，但是这两个func都没有没有参数这种模型的
	// 如果想调用父类的func函数，需要加上域分辨符
	// c1.func(); // 报错 报没有重载函数接收0个参数
	c1.Parent::func();
}

多态原理探究=================================
class Parent{
	public:
		// 当类中声明虚函数时，编译器会在类中生成一个虚函数表
		// 虚函数表是一个存储类成员函数指针的数据结构
		// 虚函数是由编译器自动生成和维护的
		// virtual成员函数会被编译器放入虚函数表中
		// 存在虚函数时，每个对象中都有一个指向虚函数表的指针（vptr指针）
		virtual public print(){}
}
void HowToPlay(Parent* base){
	// c++编译器根本不区分传来的base是子类对象还是父类对象
	// 父类对象和子类对象都有vptr指针，此处会通过vptr指针去寻找对象对应类的虚函数表，再根据虚函数表找函数的入口地址，这样就实现了迟绑定的效果（运行时的时候c++编译器采取判断）
	// 编译器在此处会判断一下print是否为虚函数，如果print不是虚函数，编译器可以直接确定被调用的成员函数（即静态链编，根据Parent类型来确定），如果print是虚函数，编译器根据对象p的vptr指针所指的虚函数表中查找print函数并调用，注意这里的查找和调用是在运行时完成的（实现所谓的动态链编）
	base -> print();
}
void main(){
	Parent p1; // 用类定义对象的时候c++编译器会在对象中添加一个vptr指针属性
	Child c1; // 继承了有虚函数的父类之后，子类中也有一个vptr指针
	
	HowToPlay(&p1);
	HowToPlay(&c1);
}

注意：
1、通过虚函数表指针vptr调用重写函数是在程序运行时进行的，因此需要通过寻址操作才能确定真正应该调用的函数，而普通成员函数是在编译时就确定了调用的函数，在效率上，虚函数的效率要低很多
2、出于效率考虑，没有必要将所有成员函数都声明为虚函数

子类的vptr指针时分步初始化的===========================
class Parent{
	public:
		Parent(int a = 0){
			this -> a = a;
			// 在子类初始化场景下调用父类中print时，这次调用实际上调用的是父类的print
			print();
		}
		virtual void print(){
			cout << "parent" << endl;
		}
	private:
		int a;
}
class Child: public Parent{
	public:
		Child(int a = 0, int b = 0): Parent(a){
			this -> b = b;
			// 在子类初始化时调用这里的print时实际上调用的是子类的print
			print();
		}
		virtual void print(){
			cout << "child" << endl;
		}
	private:
		int b;
}
void HowToPlay(Parent* base){
	base -> print();
}
void main(){
	Child c1; // 定义一个子类对象，在这个过程中，在父类构造函数中调用虚函数print，能发生多态吗？答案：不能
	HowToPlay(&c1);
}
执行Child c1时会初始化c1的vptr指针，初始化过程是分步骤的
当执行父类的构造函数的时候，c1.vptr会指向父类的虚函数表
当父类的构造函数运行完毕以后，会把c1的vptr指针指向子类的虚函数表

=======================
class Parent{
	public:
		Parent(int a = 0){
			this -> a = a;
		}
		virtual void print(){
			cout << "parent" << endl;
		}
	private:
		int a;
}
class Child: public Parent{
	public:
		Child(int a = 0, int b = 0): Parent(a){
			this -> b = b;
		}
		Child(int b = 0):Parent(0){
			this -> b = b;
		}
		virtual void print(){
			cout << "child" << endl;
		}
	private:
		int b;
}
void HowToPlay(Parent* base){
	base -> print();
}
void main(){
	Child c1; // 定义一个子类对象，在这个过程中，在父类构造函数中调用虚函数print，能发生多态吗？答案：不能
	Child* pC = NULL;
	Parent* pP = NULL;
	
	Child array[] = {Child(1), Child(2), Child(3)};
	pP = array;
	pC = array;
	
	pP -> print();
	pC -> print();
	// 父类对象和子类对象占用的空间有可能不一样，所以父类指针pP往后指不一定正好指向下一个Child对象，所以很有可能报错
	pP++;
	pC++;
}

抽象类和纯虚函数======================
纯虚函数为各派生类提供一个公共界面
纯虚函数所在的类不能实例化，但是可以定义指针类型

// 含有纯虚函数的类是抽象类，不可以被实例化
class Figure{
	public:
		virtual void getArea() = 0; // 纯虚函数
}
class Circle: public Figure{
	public:
		Circle(int a, int b){
			this -> a = a;
			this -> b = b;
		}
		virtual void getArea(){
			cout << 3.14 * a * a << endl;
		}
	private:
		int a;
		int b;
}
class Tri: public Figure{
	public:
		Tri(int a, int b){
			this -> a = a;
			this -> b = b;
		}
		virtual void getArea(){
			cout << 1 / 2 * a * b << endl;
		}
	private:
		int a;
		int b;
}
class Square: public Figure{
	public:
		Square(int a, int b){
			this -> a = a;
			this -> b = b;
		}
		virtual void getArea(){
			cout << a * b << endl;
		}
	private:
		int a;
		int b;
}
void objplay(Figure* base){
	base -> getArea();
}
void main(){
	Figure* base = NULL; // 可以定义指针类型
	
	Circle c1(10, 20);
	Tri t1(10, 20);
	Square s1(10, 20);
	
	objplay(&c1);
	objplay(&t1);
	objplay(&s1);
}

信息系统框架继承第三方产品案例==========================
CSocketProtocal.h===================协议层只需制定标准（通过抽象类+虚函数制定）
#pragma once
class CSocketProtocal{
	public:
		virtual int cltSocketInit() = 0;
		virtual int cltSocketSend(unsigned char* buf, int buflen) = 0;
		virtual int cltSocketRev(unsigned char* buf, int* buflen) = 0;
		virtual int cltSocketDestroy() = 0;
}


CEncDesProtocal.h====================数据加密解密
#pragma once

class CEncDesProtocal{
	public:
		CEncDesProtocal(){
			
		}
		virtual ~CEncDesProtocal(){
			
		}
		virtual int EncData(unsigned char* plain, int plainlen, unsigned char* cryptdata, int* cryptlen) = 0;
		virtual int DecData(unsigned char* cryptdata, int cryptlen, unsigned char* plain, int* plainlen) = 0;
}



CSckFactoryImp1.h===================实现层实现协议层制定的标准
#pragma once
#include "CSocketProtocal.h"
class CSckFactoryImp1:public CSocketProtocal{
	public:
		virtual int cltSocketInit();
		virtual int cltSocketSend(unsigned char* buf, int buflen);
		virtual int cltSocketRev(unsigned char* buf, int* buflen);
		virtual int cltSocketDestroy();
	private:
		unsigned char* p;
		int len;
}


HwEncDec.h===================实现加密接口标准
#pragma once
#include <iostream>
using namespace std;

#include "CEncDesProtocal.h"
class HwEncDec: public CEncDesProtocal{
	public:
		virtual int EncData(unsigned char* plain, int plainlen, unsigned char* cryptdata, int* cryptlen);
		virtual int DecData(unsigned char* cryptdata, int cryptlen, unsigned char* plain, int* plainlen);
}


CSckFactoryImp1.cpp===================实现Socket标准
#include "CSckFactoryImp1.h"
int CSckFactoryImp1::cltSocketInit(){
	p = NULL;
	len = 0;
	return 0;
}
int CSckFactoryImp1::cltSocketSend(unsigned char* buf, int buflen){
	p = (unsigned char*)malloc(sizeof(unsigned char) * buflen);
	if (p == NULL){
		return -1;
	}
	memcpy(p, buf, buflen);
	return 0;
}
int CSckFactoryImp1::cltSocketRev(unsigned char* buf, int* buflen){
	if (buf == NULL || buflen == NULL) {
		return -1;
	}
	*buflen = this -> len;
	memcpy(buf, this -> p, this -> len);
	len = buflen;
	return 0;
}
int CSckFactoryImp1::cltSocketDestroy(){
	if (p != NULL) {
		free(p);
		p = NULL;
		len = 0;
	}
	return 0;
}


HwEncDec.cpp====================实现加密解密标准
#include <iostream>
using namespace std;
#include "HwEncDec.h"
#include "des.h" // 第三方加密库

// int DesEnc(unsigned char* pInData, int nInDataLen, unsigned char* pOutData, int* pOutDataLen){}
// int DesDec(unsigned char* pInData, int nInDataLen, unsigned char* pOutData, int* pOutDataLen){}
int HwEncDec::EncData(unsigned char* plain, int plainlen, unsigned char* cryptdata, int* cryptlen){
	DesEnc(plain, plainlen, cryptdata, &cryptlen);
	return 0;
}
int HwEncDec::DecData(unsigned char* cryptdata, int cryptlen, unsigned char* plain, int* plainlen){
	DesDec(cryptdata, cryptlen, plain, &plainlen){}
	return 0;
}



mainclass.cpp===================
#include "CSocketProtocal.h"
#include "CSckFactoryImp1.h"
#include "CEncDesProtocal.h"
#include "HwEncDec.h"

// 抽象类在多继承中的运用，在其他高级语言中这叫做接口
// class MainOp: public CSocketProtocal, public CEncDesProtocal{
// 	
// }
// 除了多继承之外还可以通过组合的方式来实现
class MainOp{
	public:
		MainOp(){
			this -> sp = NULL;
			this -> ed = NULL;
		}
		MainOp(CSocketProtocal* sp, CEncDesProtocal* ed){
			this -> sp = sp;
			this -> ed = ed;
		}
		setCSocketProtocal(CSocketProtocal* sp){
			this -> sp = sp;
		}
		setCEncDesProtocal(CEncDesProtocal* ed){
			this -> ed = ed;
		}
	public:
		int SckSendAndRec(unsigned char* in, int inlen, unsigned char* out, int* outlen){
			int ret = 0;
			// 初始化socket
			ret = sp->cltSocketInit();
			if (ret != 0) {
				goto End;
			}
			// 将发送数据加密
			unsigned char* encdata[4096];
			int encdatalen = 0;
			ret = ed->EncData(in, inlen, encdata, &encdatalen);
			if (ret != 0) {
				goto End;
			}
			// 发送
			// ret = sp->cltSocketSend(in, inlen);
			// 要发送密文
			ret = sp->cltSocketSend(encdata, &encdatalen);
			if (ret != 0) {
				goto End;
			}
			// 接收响应
			unsigned char* decdata[4096];
			int decdatalen = 0;
			ret = sp->cltSocketRev(decdata, &decdatalen);
			if (ret != 0) {
				goto End;
			}
			// outlen已经是指针类型，不必再取
			ret = ed->DecData(decdata, decdatalen, out, outlen);
			if (ret != 0) {
				goto End;
			}
			
		End:
			ret = sp->cltSocketDestroy();
			return 0;
		}
	private:
		CSocketProtocal* sp;
		CEncDesProtocal* ed;
}


void main(){
	CSocketProtocal* sp = NULL;
	sp = new CSocketProtocal;
	
	unsigned char in[4096];
	int inlen = 9;
	unsigned char out[4096];
	int outlen = 0;
	
	// 加密解密类
	CEncDesProtocal* ed = NULL;
	ed = new HwEncDec;
	
	ret = SckSendAndRec(sp, ed, in, inlen, out, &outlen);
	if (ret != 0) {
		printf("err");
		return ret;
	}
	delete sp; // 想通过父类指针释放所有的子类对象资源
	
	//=================使用MainOp类之后的调用方式===========================
	MainOp* myMainOp = new MainOp;
	CSocketProtocal* sp = NULL;
	CEncDesProtocal* ed = NULL;
	
	myMainOp->setCSocketProtocal(sp);
	myMainOp->setCEncDesProtocal(ed);
	
	ret = myMainOp->SckSendAndRec(in, inlen, out, &outlen);
	if (ret != 0) {
		printf("err");
		return ret;
	}
	delete sp;
	delete ed;
	delete myMainOp;
}

============================
void main(){
	// 定义数组类型
	int a[10]; // a代表数组首元素的地址 &a代表整个数组的首地址 因此a和&a的步长不一样
	// a+1会前进4个字节，&a+1前进40字节 即a的步长是4字节，&a的步长是40字节
	typedef int (myTypeArray)[10];
	myTypeArray myArray;
	myArray[0] = 10;
	
	// 定义指针数组类型
	typedef int (*PTypeArray)[10];
	PTypeArray myPArray;
	myPArray = &a;
	// myPArray是二级指针
	(*myPArray)[0] = 20;
	printf(a[0]); // 20
	
	// 定义指向数组类型的指针
	int (*MyPointer)[10]; // 效果相当于typedef int (*PTypeArray)[10]; PTypeArray myPArray;
	MyPointer = &a;
	(*MyPointer)[0] = 40;
}

void main(){
	// 定义函数类型
	typedef int (MyFuncType)(int a, int b);
	MyFuncType* myPointerFunc = NULL;
	
	// 加不加&都可以
	myPointerFunc = &add;
	myPointerFunc(3, 4);
	
	myPointerFunc = add;
	myPointerFunc(3, 4);
	
	
	// 定义函数指针类型
	typedef int (*MyPointerFuncType)(int a, int b);
	MyPointerFuncType myPointerFunc;
	
	myPointerFunc = add;
	myPointerFunc(3, 4);
	
	
	// 直接定义函数指针变量
	int (*MyPointerFunc)(int a, int b);
	MyPointerFunc = add;
	MyPointerFunc(7, 9);
}
函数指针做参数===============================
int add(int a, int b){
	return a + b;
}
int add2(int a, int b){
	return a + b;
}

typedef int (*MyTypeFuncAdd)(int a, int b);

int MainOp(MyTypeFuncAdd myFuncAdd){
	return myFuncAdd(5, 6);
}

int MainOp2(int (*MyPointerFuncAdd)(int a, int b)){
	return MyPointerFuncAdd(5, 6);
}
void main(){
	MyTypeFuncAdd myFuncAdd = NULL;
	add(1, 2);
	
	myFuncAdd = add;
	myFuncAdd(1, 2);
	
	MainOp2(add);
	MainOp(add);
	
	// 可以调用同类函数
	MainOp2(add2);
	MainOp(add2);	
}

C动态库升级成框架案例======================================

函数模板(泛型编程)=============================
template <typename T>
void myswap(T &a, T &b){
	T c;
	c = a;
	a = b;
	b = c;
}
void main(){
	int x = 10;
	int y = 20;
	
	// 显式类型调用
	myswap<int>(x, y);
	
	// 自动类型推导 很少使用
	myswap(x, y);
	
	char a = 'a';
	char b = 'b';
	myswap<char>(a, b);
}

函数模板做函数参数===================
template <typename T, typename T2>
int mySort(T *array, T2 size){
	T2 i,j;
	T tmp;
	if(array == NULL){
		return -1;
	}
	for(i = 0; i < size; i++){
		for(j = i + 1; j < size; j++){
			tmp = array[i];
			array[i] = array[j];
			array[j] = tmp;
		}
	}
	return 0;
}
template <typename T, typename T2>
int myPrint(T* aray, T2 size){
	return 0;
}
void main(){
	int array[] = {11, 22, 33, 44};
	
	int size = sizeof(array) / sizeof(*array);
	mySort<int, int>(array, size);
}
=========================
template <typename T>
void myswap(T &a, T &b){}

void myswap(int a, int b){}

// 两个myswap之间的关系是重载关系

void main(){
	int a = 10;
	char c = 'z';
	
	myswap(a, c);
	myswap(c, a);
	myswap(a, a);
	
	// 普通函数可以进行隐式类型转换	
	// 调用函数模板（本质：类型参数化），将严格按照类型进行匹配，不会进行自动类型转换
}

函数模板可以像普通函数一样被重载
C++编译器优先考虑普通函数
如果函数模板可以产生一个更好的匹配，那么选择模板
可以通过空模板实参列表的语法限定编译器只通过模板匹配

int Max(int a, int b){}

template<typename T>
T Max(T a, T b){}

template<typename T>
T Max(T a, T b, T c){}

void main(){
	int a = 1;
	int b = 2;
	
	cout << Max(a, b) << endl; // 当函数模板和普通函数都符合调用时，优先选择普通函数
	cout << Max<>(a, b) << endl; // 若显式（强制）使用函数模板，则使用<>类型列表
	cout << Max(3.0, 4.0) << endl; // 如果函数模板产生更好的匹配，使用函数模板，因为浮点数转为整型会失真，所以不转换成整数
	cout << Max(3.0, 4.0, 5.0) << endl; // 重载
	cout << Max('a', 100) << endl; // 函数模板对于类型要求很严格，因此这里调用普通函数 可以隐式类型转换
}

=========================模板机制探究
gcc编译过程
预处理
编译
汇编
连接

gcc *.c -o 1.exe // 总的编译步骤
gcc -E l.c -o 1.i // 宏定义展开
gcc -S 1.i -o 1.s // 生成汇编    也可以直接从cpp文件编译成汇编 gcc -S 1.cpp -o 1.s
gcc -c 1.s -o 1.o // 生成目标文件
gcc 1.o    -o 1.exe // 通过链接器连接成可执行程序

通过把cpp文件编译成汇编之后，发现编译器会根据对模板函数的调用类型生成对应类型的函数
例如：mySort<int, int>(1, 2)和mySort<char, char>('a', 'c')会生成两个mySort的函数定义

编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译

类模板（很难）==============================
单个类模板基本语法
template<typename T>
class A{
	public:
		A(T a = 0){
			this -> a = a;
		}
	public:
		void printA(){
			cout << "a:" << a << endl;
		}
	protected:
		T a;
}

// 模板类派生普通类
// 子模板类派生时，需要具体化模板类，c++编译器需要知道父类的数据类型具体是什么
// 要知道父类所占多大内存，只有数据类型固定下来才知道如何分配内存
class B:public A<int>{
	public:
		B(int a = 10, int b = 20):A<int>(a){
			this -> b = b;
		}
		void printB(){
			cout << a << " " << b << endl;
		}
	private:
		int b;
}


// 模板类派生模板类
template <typename T>
class C:public A<T>{
	public:
		C(T c, T a):A<T>(a){
			this -> c = c;
		}
		void printC(){
			cout << c << endl;
		}
	protected:
		T c;
}

void useA(A<int> &a){
	a.printA();
}
void main(){
	// 模板类是抽象的，需要进行类型具体化，类似Java语法
	A<int> a1(100);
	useA(a1);
	a1.printA();
	
	
	// 模板类派生普通类
	B b1(1, 2);
	
	
	// 模板类派生模板类
	C<int> c1(1, 2);
	c1.printC();
}

实际开发中，函数实现和函数定义通常不在一个文件中，对于类和其方法文件管理的问题，有以下三种方案：
1、类的声明，以及所有方法的实现全部写在一个文件中
2、类的声明写在一个文件中，所有方法的实现写在另一个文件中
3、类的声明写在一个文件中，各个方法写在单独的文件中
第一种方式：所有方法都写在类内部的情况=======================
template<typename T>
class Complex{
	public:
		Complex(T a, T b){
			this -> a = a;
			this -> b = b;
		}
		void printCom(){
			cout << a << " " << b << endl;
		}
		// 运算符重载部分：
		Complex operator+(Complex& c2){
			Complex tmp(a + c2.a, b + c2.b);
			return tmp;
		}
		// 使用模板后友元函数写在外面会报错，暂时先放到类内部
		friend ostream& operator<<(ostream& out, Complex& c3)
			out << c3.a << " " << c3.b << endl;
			return out;
		}
		
		// 滥用友元函数：
		friend Complex MySub(Complex& c1, Complex& c2){
			Complex tmp(c1.a - c2.a, c1.b - c2.b);
			return tmp;
		}
	private:
		T a;
		T b;
}
// 使用模板后友元函数写在外面会报错，暂时先放到类内部
// ostream& operator(ostream& out, Complex& c3){
// 	out << c3.a << " " << c3.b << endl;
// 	return out;
// }
void main(){
	Complex<int> c1(1, 2);
	Complex<int> c2(3, 4);
	
	Complex<int> c3 = c1 + c2;
	
	// 滥用友元函数：
	Complex<int> c4 = MySub(c1, c2);
	cout << c4 << endl;
}



第二种方式：所有方法写在类的外部==========================
template<typename T>
class Complex{
	public:
		Complex(T a, T b);
		void printCom();
		
		// 运算符重载部分：
		Complex operator+(Complex& c2);
		
		// 注意：将通过友元函数实现 友元函数运算符重载时在运算符后面可能需要加上泛型标识才可以编译通过
		friend ostream& operator<< <T> (ostream& out, Complex& c3);
		
		// 滥用友元函数：如果本身不必使用友元函数，但是依然用了，即使按照上面的方法加上<T>也无济于事
		friend Complex MySub(Complex& c1, Complex& c2);
		// friend Complex MySub<T>(Complex& c1, Complex& c2); 加上<T>依然过不了编译
	private:
		T a;
		T b;
}


template <typename T>
// 注意域分辨符Complex<T>要加上泛型
Complex<T>::Complex(T a, T b){
	this -> a = a;
	this -> b = b;
}

template <typename T>
void Complex<T>::printCom(){
	cout << a << " " << b << endl;
}

// 成员函数实现的运算符重载
template <typename T>
// 注意：函数的参数和返回值都要加上泛型符<T>
Complex<T> Complex<T>::operator+(Complex<T>& c2){
	// 在方法的内部，写不写泛型标识都可以
	Complex tmp(a + c2.a, b + c2.b);
	// Complex<T> tmp(a + c2.a, b + c2.b);也可以
	return tmp;
}

// 友元函数实现的运算符重载
// 模板是两次编译生成的，两次生成的函数头不一样时会编译报错
// 我们通过在类声明中给友元函数实现的<<运算符重载函数声明处的运算符后面添加泛型标识来解决该报错
// 注意这里不能加类的域分辨符，因为友元函数是全局函数，不属于某个类
template <typename T>
ostream& operator<<(ostream& out, Complex<T>& c3)
	out << c3.a << " " << c3.b << endl;
	return out;
}

// 滥用友元函数的后果：
// 友元函数是全局函数，所以不可以加域分辨符
template <typename T>
Complex<T> MySub(Complex<T>& c1, Complex<T>& c2){
	Complex tmp(c1.a - c2.a, c1.b - c2.b);
	return tmp;
}

void main(){
	Complex<int> c1(1, 2);
	Complex<int> c2(3, 4);
	
	Complex<int> c3 = c1 + c2;
	
	// 滥用友元函数：
	Complex<int> c4 = MySub(c1, c2);
	cout << c4 << endl;
}


第三种方式：所有函数实现写在函数外部，.h和.cpp分开================================
// 声明文件.h
#pragma once

#include <iostream>
using namespace std;

template<typename T>
class Complex{
	public:
		Complex(T a, T b);
		void printCom();
		Complex operator+(Complex& c2);		
		friend ostream& operator<< <T> (ostream& out, Complex& c3);		
	private:
		T a;
		T b;
}

// 实现文件 实际开发中经常把该文件后缀写为.hpp
#include "声明的头文件(.h文件)"
上面写的所有的文件

// main函数文件
#include "实现文件(.cpp文件)" // 注意不是包含.h头文件

// 注意：滥用的友元函数在这样分开写的时候无法解决

==================类模板中的静态成员，不同的泛型拥有各自的静态成员
template <typename T>
class AA{
	public:
		static T m_a;
}

template <typename T>
T AA<T>::m_a = 0;

void main(){
	AA<int> a1, a2, a3;
	a1.m_a = 10;
	a2.m_a++;
	a3.m_a++; // 12
	
	AA<char> c1, c2, c3;
	a1.m_a = 'a';
	a2.m_a++;
	a3.m_a++; // 99
}

设计数组模板类MyVector，完成对int char Teacher类型元素的管理==================
#include <iostream>
using namespace std;

template<typename T>
class MyVector{
	public:
		MyVector(int size = 0);
		MyVector(const MyVector& obj); // 拷贝构造函数
		~MyVector(); // 析构函数
		
		// 运算符重载
		T& operator[](int index);
		MyVector& operator=(const MyVector& obj);
		friend ostream& operator<< <T>(ostream& out, const MyVector& obj);
		
		// 获取长度
		int getLen(){return m_len;}
	protected:
		T* m_space;
		int m_len;
		
}

=================
实现文件：
#include <iostream>
using namespace std;
#include "MyVector.h"

template <typename T>
MyVector<T>::MyVector(int size = 0){
	m_space = new T[size];
	m_len = size;
}

template <typename T>
MyVector<T>::MyVector(const MyVector& obj){
	m_len = obj.m_len;
	m_space = new T[m_len];
	
	for (int i = 0; i < m_len; i++) {
		m_space[i] = obj.m_space[i];
	}
}

template <typename T>
MyVector<T>::~MyVector(){
	if (m_space != NULL){
		delete [] m_space;
		m_space = NULL;
		m_len = 0;
	}
}

// 运算符重载
template <typename T>
T& MyVector<T>::operator[](int index){
	return m_space[index];
}

template <typename T>
MyVector<T>& MyVector<T>::operator=(const MyVector<T>& obj){
	if (m_space != NULL) {
		delete [] m_space;
		m_space = NULL;
		m_len = 0;
	}
	
	m_len = obj.m_len;
	m_space = new T [m_len];
	
	for (int i = 0; i < m_len; i++) {
		m_space[i] = obj[i];
	}
	
	return *this;
}

template <typename T>
ostream& operator<<(ostream& out, const MyVector<T>& obj){
	for (int i = 0; i < obj.m_len; i++) {
		out << obj.m_space[i] << "";
	}
	out << endl;
	return out;
}

入口文件===================
#include "MyVector.cpp"
// 自定义的数组中如果放自定义的类的实例化对象并且对象成员有指针类型并且动态分配内存时
// 由于直接赋值出现的浅拷贝的问题，需要重载等号
class Teacher{
	public:
		Teacher(){
			age = 33;
			m_p = new char[1];
			//strcpy(name, "");
			strcpy(m_p, "");
		}
		Teacher(char* name, int age){
			this -> age = age;
			//strcpy(this -> name, name);
			m_p = new char[strlen(name) + 1];
			strcpy(m_p, name);
		}
		Teacher(const Teacher& obj){
			m_p = new char[strlen(obj.m_p) + 1];
			strcpy(m_p, obj.m_p);
			age = obj.age;
		}
		~Teacher(){
			if (m_p != NULL) {
				delete [] m_p;
				m_p = NULL;
			}
		}
		void printT(){
			cout << m_p << " " << age << endl;
		}
		// 运算符重载
		friend ostream& operator<<(ostream& out, Teacher& t);
		Teacher& operator=(const Teacher& obj){
			if (m_p != NULL) {
				delete [] m_p;
				m_p = NULL;
				age = 33;
			}
			m_p = new char[strlen(obj) + 1];
			strcpy(m_p, obj.m_p);
			age = obj.age;
			return *this;
		}
	private:
		int age;
		//char name[32];
		char* m_p;
}
ostream& operator<<(ostream& out, Teacher& t){
	out << t.m_p << " " << t.age << endl;
	return out;
}
void main(){
	MyVector<int> myv1(10);
	
	for(int i = 0; i < myv1.getLen(); i++){
		myv1[i] = i + 1;
		cout << myv1[i] << endl;
	}
	
	MyVector<int> myv2 = myv1;
	
	for(int i = 0; i < myv2.getLen(); i++){
		myv1[i] = i + 1;
		cout << myv2[i] << endl;
	}
	
	cout << myv2 << endl;
	
	MyVector<char> myv3(10);
	for(int i = 0; i < myv3.m_len; i++){
		
	}
	
	Teacher t1("t1", 31),Teacher t2("t1", 31),Teacher t3("t1", 31),Teacher t4("t1", 31);
	MyVector<Teacher> myv4(4);
	myv4[0] = t1;
	myv4[1] = t2;
	myv4[2] = t3;
	myv4[3] = t4;
	
	// 数组中的成员是指针类型时：
	MyVector<Teacher*> myv5(4);
	myv5[0] = &t1;
	myv5[1] = &t2;
	myv5[2] = &t3;
	myv5[3] = &t4;
	
}

c++类型转换============================
static_cast 静态类型转换
reinterpreter_cast 重新解释类型
dynamic_cast 命令上理解是动态类型转换，如子类和父类之间的多态类型转换
const_cast 字面上理解就是去const属性

4种类型转换的格式：
TYPE B = static_cast<TYPE>(a);

int main(){
	double dPI = 3.1415926;
	int num1 = (int)dPI; // C语言中类型转换
	
	//C++中静态类型转换
	//编译时C++编译器会做类型检查，如果转换失败编译不通过
	int num2 = static_cast<int>(dPI);
	
	//C中如下的依赖隐式类型转换会有警告，可以用static_cast来代替
	int num3 = dPI;
	
	char* p1 = "hello";
	int* p2 = NULL;
	//不同类型的指针之间赋值，C编译器编译时直接error，编译不通过
	p2 = p1;
	//static_cast不可以转这种
	p2 = static_cast<int*>(p1);
	
	//强制将char*转换为int*
	p2 = reinterpreter_cast<int*>(p1);
	
	cout << p1 << endl; //"hello"
	cout << p2 << endl; //某个地址
}
====================================
class Animal{
	public:
		virtual void cry() = 0;
}
class Dog:public Animal{
	public:
		virtual void cry(){
			cout << "wangwnag" << endl;
		}
		void doHome(){
			cout << "看家" << endl;
		}
}
class Cat:public Animal{
	public:
		virtual void cry(){
			cout << "miaomiao" << endl;
		}
		void doThing(){
			cout << "捉老鼠" << endl;
		}
}
class Tree{
	
}
void playObj(Animal* base){
	base -> cry();
	//希望这里识别子类对象，可以使用dynamic_cast
	//dynamic_cast运行时类型识别 向下转型
	Dog d1 = dynamic_cast<Dog*>(base);
	if (d1 != NULL) {
		d1 -> doHome();
	}
	Cat c1 = dynamic_cast<Cat*>(base);
	if (c1 != NULL) {
		c1 -> doThing();
	}
}
void main(){
	Dog d1;
	Cat c1;
	
	Animal* pBase = NULL;
	pBase = &d1;
	//pBase = &d1;可以用static_cast来代替，静态类型转换是让c++编译器在编译时检查
	pBase = static_cast<Animal*>(&d1);
	
	Tree t1;
	// c++编译器会做检查，是不相关的类型之间转换，转换会失败
	pBase = static_cast<Animal*>(&t1);
	// 重新解释，强制转换
	pBase = reinterpret_cast<Animal*>(&t1);
	
	playObj(&d1);
	playObj(&c1);
}
================================
void printBuf(const char* p){
	char* p1 = NULL;
	// 去除p的只读属性，但必须保证p的内存空间可读才可以
	// const char* -> char*
	p1 = const_cast<char*>(p);
	p[0] = 'Z'; // 不会报错
}
void main(){
	char buf[] = "abc";
	// char* myp = "abc";这种写法并没有在栈或堆上分配内存，指向的内存空间不可以改，即使用const_cast去除只读属性也不可以改
	char* myp = "abc";
	printBuf(buf);
}
异常===========================
抛异常时以类型作为依据，接收异常时也是以类型接收
void divide(int x, int y){
	if (y == 0) {
		throw x; // 抛出int类型异常，该函数不会再往后执行
	}
	cout << x/y << endl;
}
void myDivide(int x, int y){
	divide(x, y);
}
int main(){
	try{
		divide( 3, 0 );
	}catch(int e){ // 这里的e接到的是传入的x
		cout << e << endl;
	}catch(...){
		cout << "其他未知类型异常" << endl;
	}
	
	
	try{
		myDivide( 3, 0 ); //divide里面抛出了异常，myDivide没有接收，继续抛，就抛给了main函数
	}catch(int e){
		cout << e << endl;
	}catch(...){
		cout << "其他未知类型异常" << endl;
	}
	
	// 如果抛出了异常，但是没有任何地方捕获，程序会终端down掉
	
	try{
		throw 'Z';
	}catch(int e){
		// throw出来了一个char类型的值，在int类型catch中无法接收
	}
	
	// 进入到try语句块中的代码发生异常时try语句块内在栈上开辟的变量给析构掉
}

在函数声明的时候可以规定只能抛出某些类型的异常，如果不写可以抛出任何类型
void func() throw (int, char, char*);

异常变量声明周期================================
// 传统的错误处理机制
int my_strcpy(char* to, char* from){
	if (from == NULL) {
		return 1;
	}
	if (to == NULL) {
		return 2;
	}
	// copy场景检测
	if (*from == 'a') {
		return 3;
	}
	while (*from != '\0') {
		*to = *from;
		to++;
		from++;
	}
	*to = '\0';
	return 0;
}
// try catch处理方式
void my_strcpy1(char* to, char* from){
	if (from == NULL) {
		throw "源buf出错\n";
	}
	if (to == NULL) {
		throw "目标buf出错\n";
	}
	// copy场景检测
	if (*from == 'a') {
		throw "未知错误\n";
	}
	while (*from != '\0') {
		*to = *from;
		to++;
		from++;
	}
	*to = '\0';
}

class BadSrcType{}
class BadDestType{}
class BadProcessType{
	public:
		BadProcessType(){
			cout << "BadProcessType构造" << endl;
		}
		~BadProcessType(){
			cout << "BadProcessType析构" << endl;
		}
		BadProcessType(const BadProcessType& obj){
			cout << "BadProcessType拷贝构造" << endl;
		}
}
void my_strcpy3(char* to, char* from){
	if (from == NULL) {
		throw BadDestType();
	}
	if (to == NULL) {
		throw BadDestType();
	}
	// copy场景检测
	if (*from == 'a') {
		throw BadProcessType();
	}
	while (*from != '\0') {
		*to = *from;
		to++;
		from++;
	}
	*to = '\0';
}

void main1(){
	int ret = 0;
	char buf1[] = "abcdefg";
	char buf2[1024];
	
	ret = my_strcpy(buf1, buf2);
	if (ret != 0) {
		switch(ret){
			case 1:
				printf("源buf出错\n");
				break;
			case 2:
				printf("源buf出错\n");
				break;
			case 3:
				printf("源buf出错\n");
				break;
			default:
				printf("未知错误\n");
				break;
		}
	}
}

void main(){
	int ret = 0;
	char buf1[] = "abcdefg";
	char buf2[1024];
	
	try{
		my_strcpy1(buf1, buf2);
	}catch(int e){ // 可以给异常起名字，也可以不起
		
	}catch(char* e){ my_strcpy1中传来的char*类型的数据是常量，因此在这里e也可以拿到这个常量数据
		
	}catch(BadSrcType e){ // 将会把throw那里的BadSrcType()创建的对象拷贝给了这里的e，而不是直接把BadSrcType()对象赋值给e，即遵循函数调用时的规则
	
	}catch(BadDestType e){
	
	}catch(BadProcessType e){ // 如果这里catch异常的时候使用的是异常变量，则进行拷贝构造，最后会把e和throw时抛出的BadProcessType()两个对象都析构掉，即调用两次析构函数
	
	}catch(BadProcessType& e){ // 此处会报错，同一类型的异常变量和引用不可以都写上
		
	}catch(...){
	
	}
	
	try{
		my_strcpy1(buf1, buf2);
	}catch(BadProcessType& e){ // 构造函数和析构函数都只执行了一次，即使用引用时会使用throw时候的那个对象
		
	}catch(BadProcessType* e){ // 引用和指针可以写在一起，指针和元素也可以写在一起
	
	}
	
	try{
		my_strcpy1(buf1, buf2);
	}catch(BadProcessType* e){ // 指针也是一种类型，throw的时候throw的是一个对象，而不是一个地址，所以这里根本接不到BadProcessType()这个异常对象
		// 此处需要注意的是如果抛异常的地方写成了throw &(BadProcessType());走到这里虽然也可以通过e接收到异常对象，但在此通过e接收到的异常对象指向的内存空间已经被析构，e将指向野指针
		// 因此，如果想要throw一个指针类型的异常，必须要在堆中分配内存，即写成throw new BadProcessType; // 注意没括号，然后在catch里面delete析构
		// 手动管理内存出现内存泄露的概率非常高，因此通常都是通过引用来抛异常
	}
}

C++提供了标准异常库
ios
istream		ostream
ifstream

void main(){
	int myInt;
	long myLong;
	char mybuf[1024];
	
	cin >> myInt;
	
	cin >> myLong;
	
	cin >> mybuf; // 不能接收空格，遇见空格停止接收数据
	
	char ch;
	// ctrl + Z是EOF
	while((ch = cin.get()) != EOF){
		cout << ch << endl;
	}
	// 注意，缓冲区的效果
	
	// =================================
	
	// 如果缓冲区没有数据，则程序阻塞，而缓冲区一旦有数据，程序不会阻塞
	char a, b, c;
	// 刚上来的时候缓冲区肯定没数据，因此这里会阻塞，也就是等待用户输入
	// 假设我们输入了abcdefghij
	cin.get(a);
	cin.get(b);
	cin.get(c);
	cout << a << b << c;
	// 上面的cout输出完了以后由于缓冲区依然有数据（defghij）
	// 因此这里就不会中断了，也就是不会等待用户输入而是直接把def输出出来了
	cin.get(a).get(b).get(c); // 可以链式编程
	cout << a << b << c;
	
	// =================================
	
	char buf1[256];
	char buf2[256];
	
	cin >> buf1;
	// 假设我们输入了aa bb cc dd
	// getline可以接受空格
	cin.getline(buf2, 256);
	
	cout << buf1 << buf2 << endl;
	// 得到结果如下：
	// aa
	// bb cc dd
	
	// =================================
	cin >> buf1;
	// 假设输入了aa  bbccdd
	cin.ignore(2); //忽略接下来的两个字符
	cin.getline(buf2, 256);
	// buf1是aa，buf2是bbccdd
	
	// =================================
	int myint = cin.peek(); // 查看一下缓冲区是否有数据，如果有数据就把第一个字符返回给myint
	// 但是如果缓冲区没有数据，会一直在此处于中断状态
	
	// =================================
	cin.pushstack();
	
	// =================================
	cout.put('h').put('e').put('l'); // 输出hel
	
	char* p = "hello";
	cout.write(p, strlen(p)) << endl;
	cout.write(p, strlen(p) - 2) << endl;
	cout.write(p, strlen(p) + 2) << endl; // 比较危险，可能会出乱码
	
	// 格式化输出=================================
	cout.width(30);
	cout.fill('*');
	cout.setf(ios::showbase);
	cout.self(ios::internal);
	
	// 使用控制符 需要加上<iomainp>头文件
	// 在此的意思就是把123按照setw(30) setfill('*') setiosflags(ios::showbase)等控制条件输出
	cout << setw(30)
		<< setfill('*')
		<< setiosflags(ios::showbase)
		<< setiosflags(ios::)
		<< hex
		<< 123;
}

文件io=====================================
#include "fstream"
void main(){
	char* fname = "c:/2.txt";
	ofstream fout(fname); // 建立一个输出流，和文件关联
	
	fout << "abc" << endl;
	fout << "def" << endl;
	
	fout.close();
	
	// 读文件
	ifstream fin(fname); // 建立一个输入流，和文件关联
	while(fin.get(ch)){
		cout << ch;
	}
	fin.close();
	
	// fout构造函数第二个参数控制打开的方式
	ofstream fout(fname, ios::app | ios::ate);
	if (!fout) { // 判断条件也可以写成fout.fail()
		cout << "打开文件失败" << endl;
	}
}

读或写二进制文件===============
class Teacher{
public:
	Teacher(){
		age = 33;
		strcpy(name, "");
	}
	Teacher(int age, char* name){
		this -> age = age;
		strcpy(this -> name, name);
	}
	void printT(){
		cout << age << name << endl;
	}
private:
	int age;
	char* name;
}
void main(){
	char* fname = "c:/2.dat";
	ofstream fout(fname, ios::binary); // 二进制方式打开文件
	
	Teacher t1(21, "abc");
	Teacher t2(21, "abc");
	
	fout.write((char*)&t1, sizeof(t1));
	fout.write((char*)&t2, sizeof(t2));
	fout.close();
	
	// 读文件
	ifstream fin(fname);
	Teacher tmp;
	
	fin.read((char*)&tmp, sizeof(Teacher));
	tmp.printT();
	
	fin.read((char*)&tmp, sizeof(Teacher));
	tmp.printT();
	
	fin.close();
}

STL==========================
STL六大组成部分：容器 算法 迭代器 仿函数 适配器 空间适配器
使用某个容器时需要将相应的头文件包含进来
#include "vector"
#include "algorithm"
class Teacher{
	public:
		void printT(){
			cout << age << name << endl;
		}
	private:
		int age;
		char name[64];
}
void main(){
	vector<int> v1;
	v1.push_back(1);
	v1.push_back(2);
	v1.push_back(3);
	
	// 可以用迭代器遍历
	for(vector<int>::iterator it = v1.begin(); it != v1.end(); it++){
		cout << *it << endl;
	}
	
	// 可以通过相关算法达到某种目的
	int num1 = count(v1.begin(), v1.end(), 3);
	cout << num1 << endl;
	
	
	// 容器里面放复杂数据类型===========
	Teacher t1, t2, t3;
	t1.age = 21;
	t2.age = 22;
	t3.age = 23;
	vector<Teacher> v1;
	v1.push_back(t1);	
	v1.push_back(t2);	
	v1.push_back(t3);

	for(vector<Teacher>::iterator it = v1.begin(); it != end(); it++){
		cout << it -> age << endl;
	}
	
	
	// 容器里面装指针
	Teacher* p1, * p2, * p3;
	vector<Teacher*> v1;
	v1.push_back(p1);
	v1.push_back(p2);
	v1.push_back(p3);
	for(vector<Teacher*>::iterator it = v1.begin(); it != end(); it++){
		cout << *it -> age << endl;
	}
	
	// push_back往容器里放东西的时候实际上是把源数据拷贝了一份放进去，需要注意浅拷贝问题
}

序列式容器：每个元素都有固定位置，取决于插入时机和地点，和元素值没关系
vector deque list
关联式容器：元素位置取决于特定的排序规则，和插入顺序无关
set multiset map multimap

STL中的string====================
#include "string"

void main(){
	string s1 = "abc";
	string s2("bbb");
	string s3 = s2;
	string s4 = (10, 'a'); // 长度为10，每个字符都是'a'
	
	cout << "s1:" << s1 << endl;
	cout << "s2:" << s2 << endl;
	cout << "s3:" << s3 << endl;
	cout << "s4:" << s4 << endl;
	
	// 遍历
	for(int i = 0; i < s1.length(); i++){
		cout << s1[i] << endl;
	}
	
	// 迭代器遍历
	for(string::iterator it = s1.begin(); it != s1.end(); it++){
		cout << *it << endl;
	}
	
	try{
		for(int i = 0; i < s1.length() + 3; i++){
			cout << s1.at(i) << endl; //at和[]的区别是at访问越界的下标可以抛出异常，而[]形式访问越界时直接使程序down掉
		}
	}catch(...){
		
	}
	
	// 和字符数组指针之间转换
	string s1 = "aaa";
	printf("%s", s1.c_str());
	
	// 字符串拷贝
	char buf1[128] = {0};
	s1.copy(buf1, 3, 0); // 将s1中的字符数组内容拷贝到buf1字符数组中，从第0个开始拷贝，拷贝3个字符
	// 注意指拷贝3个字符进去，并没有把最后一个字符设置为0
	
	// 字符串连接
	string s1 = "aaa";
	string s2 = "bbb";
	s1 = s1 + s2;
	cout << s1 << endl;
	
	string s3 = "aaa";
	string s4 = "bbb";
	s3.append(s4); // 也可以连接字符串
	
	// 字符串查找和替换
	string s1 = "wbm hello wbm 111 wbm 222 wbm 333";
	int index = s1.find("wbm", 0); // 从s1字符串的第0个位置开始查找"wbm"第一次出现的位置，如果没找到返回-1
	cout << "index:" << index << endl;
	
	// 求wbm出现的次数以及每次出现的下标
	int offindex = s1.find("wbm", 0);
	// string:npos是静态成员，值为-1
	while(offindex != string::npos){
		cout << offindex << endl;
		offindex += 3;
		offindex = s1.find("wbm", offindex);
	}
	
	// 找到wbm之后将其替换成大写
	int offindex = s1.find("wbm", 0);
	while(offindex != string::npos){
		cout << offindex << endl;
		s1.replace(offindex, 3, "WBM"); //从offindex开始，将此后3个字符替换成"WBM"
		offindex += 3;
		offindex = s1.find("wbm", offindex);
	}
	
	string s1 = "hello1 hello2 hello3";
	// find属于算法头文件中的函数，需要引入头文件include "algrithom"
	// find返回迭代器的位置
	string::iterator it = find(s1.begin(), s1.end(), 'l');
	if(it != s1.end()){
		s1.erase(it);
	}
	
	// string& erase(int pos = 0, int n = npos); 删除从pos开始的的n个字符，返回修改后的字符串
	s1.erase(s1.begin(), s1.end()); // 将s1全部删除
	
	// string& insert(int pos, const string& s); 在pos位置插入s
	s1.insert(0, "AAA"); // 向s1开头插入AAA
	
	// string算法相关
	string s1 = "aaaBBB";
	// toupper变成大写 把s1.begin()到s1.end()的所有字符变成大写，再赋到s1.begin()位置
	transform(s1.begin(), s1.end(), s1.begin(), toupper);
	// tolower变成小写
	transform(s1.begin(), s1.end(), s1.begin(), tolower);
}

Vector容器：将元素置于一个动态数组中加以管理的容器
Vector可以随机存取元素（支持索引值直接存取，用[]操作符或at()方法）
Vector尾部添加或移除元素非常快速，但是在中部或头部插入元素或移除元素比较费时（中间删除或添加时需要把所有删除位置后面的元素向后或向前移动）
// 需要引入vector头文件
#include "vector"
void main(){
	vector<int> v1;
	v1.push_back(1);
	v1.push_back(3);
	v1.push_back(4);
	cout << v1.size() << endl;
	
	cout << v1.front() << endl; // 获取头部元素
	
	while(v1.size() > 0){
		cout << v1.back() << endl; // 获取尾部元素
		v1.pop_back(); // 删除尾部元素
	}
	
	v1.front() = 11; // v1.front返回的是引用 将最开头的元素（第0个元素）改成11
	v1.back() = 55; // 尾部同理
	
	// vector的初始化===============================
	vector<int> v1;
	v1.push_back(1);
	v1.push_back(3);
	v1.push_back(4);
	
	vector<int> v2 = v1;
	
	// vector(beg, end); 将beg到end区间中元素拷贝，该区间是左闭右开
	vector<int> v3(v1.begin(), v1.begin() + 2); // 把v1的第v1.begin()个元素到第v1.begin() + 2个元素拷贝到v3
	
	// vector(n, elem); 拷贝n个elem
	vector<int> v4(3, 9); // v4中将存在3个9
	
	// vector(const vector& vec);
	vector<int> v5(v4);
	
	// vector的遍历====================================
	vector<int> v1(10); // 注意写成vector<int> v1不可以，必须提前把内存准备好接下来才可以赋值
	for(int i = 0; i < 10; i++){
		v1[i] = i + 1;
	}
	for(int i = 0; i < 10; i++){
		cout << v1[i] << endl;
	}
	
	=======================
	vector<int> v1(10);
	v1.push_back(100);
	v1.push_back(200);
	for(int i = 0; i < v1.size(); i++){
		cout << v1[i] << endl; // 0 0 0 0 0 0 0 0 0 0 100 200 因为初始化时已经有了10个元素了，所以再往后push就是给第11 12个元素赋值了
	}	
}

迭代器=============================
void main(){
	vector<int> v1(10);
	for(int i = 0; i < 10; i++){
		v1[i] = i + 1;
	}
	// 迭代器定义的地方：
	// typedef iterator pointer;
	// typedef const_iterator const_pointer;
	// typedef _STD reverse_iterator<iterator> reverse_iterator;
	// typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
	// v1.end()指向最后一个元素后面的位置
	for(vector<int>::iterator it = v1.begin(); it != v1.end(); it++){
		cout << *it << endl;
	}
	// 逆向迭代器遍历
	for(vector<int>::reverse_iterator rit = v1.rbegin(); rit != v1.rend(); rit++){
		cout << *rit << endl;
	}
	
	// vector删除=============================
	vector<int> v1(10);
	for(int i = 0; i < 10; i++){
		v1[i] = i + 1;
	}
	
	v1.erase(v1.begin(), v1.begin() + 3); // 删除v1.begin()到v1.begin() + 3的元素
	v1.erase(v1.begin()); // 删除索引为v1.begin()位置的元素
	
	// 删除vector中值为2的元素
	for(vector<int>::iterator it = v1.begin(); it != v1.end();){
		if(*it == 2){
			it = v1.erase(it); // erase返回迭代器位置对象，删除了之后把当前迭代器位置对象赋给it
		}else{
			it++;
		}
	}
	
	v1.insert(v1.begin(), 100); // 头部插入100
	v1.insert(v1.end(), 200); // 尾部插入200
}

deque双端数组=======================================
#include "deque"
void main(){
	deque<int> d1;
	d1.push_back(1);
	d1.push_back(3);
	d1.push_back(4);
	
	d1.push_front(1);
	d1.push_front(3);
	d1.push_front(4);
	
	for(deque<int>::iterator it = d1.begin(); it != d1.end(); it++){
		cout << *it << endl;
	}
	
	cout << d1.front() << endl; // 头部元素
	cout << d1.back() << endl; // 尾部元素
	
	d1.pop_front(); // 弹出头部元素
	d1.pop_back(); // 弹出尾部元素
	
	// 用迭代器查找数组下标
	deque<int>::iterator it = find(d1.begin(), d1.end(), -33);
	if(it != d1.end()){
		cout << distance(d1.begin(), it) << endl;
	}else{
		cout << "没有找到对应值" << endl;
	}
}

stack========================
#include "stack"
class Teacher{
	public:
		int age;
		char name[32];
	public:
		void printT(){
			cout << age << endl;
		}
}
void main(){
	stack<int> s;
	for(int i = 0; i < 10; i++){
		s.push(i + 1);
	}
	cout << s.size() << endl; // 栈的大小为10
	while( !s.empty() ){
		int tmp = s.top(); // 获取栈顶元素
		cout << tmp << endl;
		s.pop(); // 删除栈顶元素
	}
	
	//===================
	Teacher t1,t2,t3;
	t1.age = 31;
	t2.age = 32;
	t3.age = 33;
	
	stack<Teacher> s;
	s.push(t1);
	s.push(t2);
	s.push(t3);
	
	while( s.empty() ){
		Teacher tmp = s.top();
		tmp.printT();
		s.pop();
	}
	
	//=================
	stack<Teacher*> s;
	s.push(&t1);
	s.push(&t2);
	s.push(&t3);
	
	while( !s.empty() ){
		Teacher* p = s.top();
		p->printT();
		s.pop();
	}
}
//队列===================
#include "queue"
void main(){
	queue<int> q;
	q.push(1);
	q.push(2);
	q.push(3);
	
	cout << q.front() << endl; // 队头元素
	cout << q.size() << endl; // 队列长度
	
	while( !q.empty() ){
		q.pop(); // 出队 因为是先进先出，所以出队顺序为1 2 3
	}
}
//list====================
双向链表容器，可以高效地进行插入删除元素
list不可以随机存取元素，所以不支持at函数与[]操作符，但是支持自增操作it++
重点理解在第3个位置插入是什么意思
#include "list"
void main(){
	list<int> l;
	cout << l.size() << endl;
	for(int i = 0; i < 10; i++){
		l.push_back(i);
	};
	cout << l.size() << endl;
	
	list<int>::iterator it = l.begin();
	
	while(it != l.end()){
		cout << *it << endl;
		it++;
	}
	
	// list不能随机访问
	it = l.begin();
	it++;
	it++;
	it++;
	// it = it + 5; // 报错，不支持随机访问容器
	list.insert(it, 100); // 在3号位置插入元素，让原来的3号位置变成4号位置，原来的4号位置变成5号位置，以此类推
	for(list<int>::iterator it = l.begin(); it != l.end(); it++){
		cout << *it << endl;
	}
	
	
	// ===============================
	// list.clear(); // 移除所有数据
	// list.erase(beg, end); // 左闭右开区间，[beg, end)，返回下一个数据的位置
	// list.erase(pos); // 删除pos位置的元素
	// list.remove(elem); // 删除容器中所有与elem值匹配的元素
	list<int>::iterator it1 = l.begin();
	list<int>::iterator it2 = l.begin();
	it2++;
	it2++;
	it2++;
	l.erase(it1, it2);
}

// priority_queue优先级队列==========================
默认是最大值优先级队列
#include "queue"
void main(){
	priority_queue<int> p1; // 默认情况下是最大值优先级队列，
	// 上面的定义相当于定义成priority_queue<int, vector<int>, less<int>> p1;
	// priority_queue<int, vector<int>, greater<int>> p1; 是最小值优先级队列
	
	p1.push(33);
	p1.push(66);
	p1.push(11);
	
	cout << p1.top() << endl; // 队头元素 66，最大的在最开头
	cout << p1.size() << endl;
}

// set集合，包含的元素是唯一的，集合中的元素按一定顺序排列，元素插入过程是按排序规则插入，不能插入指定位置
// set采用红黑树变体的数据结构实现，红黑树属于平衡二叉树，在插入操作和删除操作上比vector快
// set不可以直接存取元素（不可以使用at(pos) []）
#include "set"
void main(){
	set<int> set1;
	for(int i = 0; i < 5; i++){
		int tmp = rand();
		set1.insert(tmp);
	}
	
	// 多次插入只保留一个
	set1.insert(100);
	set1.insert(100);
	// 默认从大到小排序
	for(set<int>::iterator it = set1.begin(); it != set1.end(); it++){
		cout << *it << endl;
	}
	// 删除集合
	while( !set1.empty() ){
		set<int>::iterator it = set1.begin();
		cout << *it << endl;
		set1.erase(set1.begin());
	}
	
	// 从小到大排列set里面的数据
	set<int, less<int>> set2;
	// 从大到小排列set里面的数据
	set<int, greater<int>> set2;
}

// set中存放复杂数据类型的排序 通过仿函数和函数对象来实现
class Student{
	public:
		Student(char* name, int age){
			strcpy(this -> name = name);
			this -> age = age;
		}
		char name[64];
		int age;
	private:
}
struct FuncStudent{
	// 重载括号(函数调用)操作符
	bool operator()(const Student& left, const Student& right){
		// 如果左边的小，则返回真
		if (left.age < right.age) {
			return true;
		} else {
			return false;
		}
	}
}
void main(){
	// FuncStudent放仿函数
	set<Student, FuncStudent> set1;
	Student s1("s1", 31);
	Student s2("s2", 22);
	Student s3("s3", 33);
	Student s4("s4", 11);
	Student s5("s5", 11);
	
	set1.insert(s1);
	set1.insert(s2);
	set1.insert(s3);
	set1.insert(s4);
	set1.insert(s5); // 由于仿函数里面按照年龄做比较，因此遇到年龄一样的后面的对象将不会插入成功
	
	// 会调用仿函数自动按年龄排序
	for(set<Student, FuncStudent>::iterator it = set1.begin(); it != set1.end(); it++){
		cout << it->age << "\t" << it->name << endl;
	}
}

// 如何判断set1.insert(s1)的返回值
void main(){
	set<Student, FuncStudent> set1;
	Student s1("s1", 31);
	// pair是一个对组，可以将两个值视为一个单元，存放两个类型的值，在泛型列表中可以指定这两个值的类型
	// 通过pair1.first可以访问到第一个值，通过pair1.second可以访问到第二个值
	pair<set<Student, FuncStudent>::iterator, bool> pair1 = set1.insert(s1);
	if (pair1.second == true) {
		cout << "插入s1成功" << endl;
	} else {
		cout << "插入s1失败" << endl;
	}
}

set查找========================
void main(){
	set<int> set1;
	for(int i = 0; i < 10; i++){
		set1.insert(i + 1);
	}
	for(set<int>::iterator it = set1.begin(); it != set1.end(); it++){
		cout << *it << endl;
	}
	
	set<int>::iterator it0 = set1.find(5); // 查找值为5的迭代器
	cout << *it0 << endl;
	
	int num1 = set1.count(5); // 求值等于5的元素的个数，要么是0，要么是1
	cout << num1 << endl;
	
	set<int>::iterator it1 = set1.lower_bound(5); // 返回第一个大于等于5的元素的迭代器的位置
	
	set<int>::iterator it2 = set1.upper_bound(5);
	
	pair<set<int>::iterator, set<int>::iterator> mypair = set1.equal_range(5); //
	pair<set<int>::iterator it3 = mypair.first;
	pair<set<int>::iterator it4 = mypair.second;
}
// multiset同一个值可以出现多次
#include "set"
void main(){
	multiset<int> set1;
	set1.insert(1);
	set1.insert(1);
	set1.insert(2);
	set1.insert(3);
	set1.insert(1);
	
	for(multiset<int>::iterator it = set1.begin(); it != set.end(); it++){
		cout << *it << endl;
	}
	
	while(!set1.empty()){
		multiset<int>::iterator it = set1.begin();
		cout << *it << endl;
		set1.erase(it);
	}
}
// map容器
map是标准的关联式容器，一个map是一个键值对序列，它提供基于key的快速检索能力
map中key是唯一的，元素按照一定顺序排列，元素插入过程是按排序规则插入的，不能指定插入位置
map的具体实现采用红黑树的平衡二叉树的数据结构，在插入操作和删除操作上比vector快
map可以直接存取key所对应的value，支持[]操作符，如map[key] = value;
multimap与map的区别：map支持唯一键值，每个键只能出现一次，而multimap中相同键可以出现多次，multimap不支持[]操作符
#include "map"
#include "string"
void main(){
	map<int, string> map1;
	// 插入操作共4种方法
	map1.insert(pair<int, string>(1, "teacher01"));
	map1.insert(pair<int, string>(2, "teacher02"));
	
	map1.insert(make_pair(3, "teacher04"));
	map1.insert(make_pair(4, "teacher05"));
	
	map1.insert(map<int, string>::value_type(5, "teacher05"));
	map1.insert(map<int, string>::value_type(6, "teacher06"));
	
	map1[7] = "teacher07";
	map1[8] = "teacher08";
	
	for(map<int, string>::iterator it = map1.begin(); it != map1.end(); it++){
		cout << it -> first << " " << it -> second << endl;
	}
	
	while(!map.empty()){
		map<int, string>::iterator it = map1.begin();
		cout << it->first << " " << it->second << endl;
		map1.erase(it);
	}
}

insert方法返回的是pair<iterator, bool>

void main(){
	map<int, string> map1;
	pair<map<int, string>::iterator, bool> mypair1 = map1.insert(pair<int, string>(1, "teacher01"));
	
	if (mypair1.second == true) {
		cout << "插入成功" << endl;
		cout << "key为" << mypair1.first->first << "value为" << mypair1.first->second << endl;
	}
	
	map1[8] = "teacher08";
	map1[8] = "teacher88"; // 如果通过[]的形式操作一个已经存在的key的value，则后面的值"teacher88"将覆盖之前该key里面存着的值"teacher08"
}

void main(){
	map<int, string>::iterator it2 = map1.find(100); // 查键是100的
	if (it2 == map1.end()){
		cout << "key为100的值不存在";
	} else {
		cout << it2->first << " " << it2->second << endl;
	}
	
	pair<map<int, string>::iterator, map<int, string>::iterator> mypair = map1.equal_range(5); // 返回两个迭代器 形成一个pair
	// 第一个迭代器是>=5的位置
	// 第二个迭代器是=5的位置
	if (mypair.first == map1.end()){
		cout << "第一个>=5的位置不存在" << endl;
	} else {
		cout << mypair.first->first << " " << mypair.first->second << endl;
	}
	
	if (mypair.second == map1.end()){
		cout << "第二个>5的位置不存在" << endl;
	} else {
		cout << mypair.second->first << " " << mypair.second->second << endl;
	}
}
multimap===================
1个key值可以对应多个value  在SQL分组中用的很多
#include "map"
class Person{
	public:
		string name;
		int age;
		string tel;
		double saly;
}
void main(){
	Person p1, p2, p3, p4, p5;
	
	p1.name = "w1";
	p1.age = 31;
	
	p1.name = "w2";
	p1.age = 31;
	
	p1.name = "w3";
	p1.age = 31;
	
	p1.name = "w4";
	p1.age = 31;
	
	p1.name = "w5";
	p1.age = 31;
	
	multimap<string, Person> map2; // key为部门名，
	// sale部门
	map2.insert(make_pair("sale", p1));
	map2.insert(make_pair("sale", p2));
	map2.insert(make_pair("development", p3));
	map2.insert(make_pair("development", p4));
	map2.insert(make_pair("finacial", p5));
	
	for(multimap<string, Person>::iterator it = map2.begin();it != map2.end(); it++){
		cout << it->first << " " << it->second.name << endl;
	}
	
	cout << map2.count("development") << endl; // development部门人数
	
	int num2 = map2.count("development"); // 统计development部门人数
	multimap<string, Person>::iterator it2 = map2.find("development");
	int tag = 0;
	while(it2 != map2.end() && tag<num2){
		cout << it2->first << " " << it2->second.name << endl;
		it2++;
		tag++;
	}
}
// 修改multimap中的值
void main(){
	// 按条件检索数据修改
	for(multimap<string, Teacher>::iterator it=map2.begin(); it < map2.end(); it++){
		cout << it->first << " " << it->second.name << endl;
		if(it->second.age == 32){
			it->second.name = "name32";
		}
	}
}

// 值拷贝语义
#include "vector"
class Teacher{
	public:
		Teacher(char* name, int age){
			m_pname = new char[strlen(name) + 1];
			strcpy(m_pname, name);
			m_age = age;
		}
		~Teacher(){
			delete [] m_pname;
			m_pname = NULL;
			m_age = 0;
		}
		Teacher(const Teacher& obj){
			m_p = new char[strlen(obj.m_pname) + 1];
			strcpy(m_pname, obj.m_pname);
			m_age = obj.m_age;
		}
		void printT(){
			cout << m_pname << " " << m_age << endl;
		}
		Teacher& operator=(const Teacher& obj){
			// 先把t2的旧内存释放掉
			if (m_pname != NULL) {
				delete [] m_pname;
				m_pname = NULL;
				m_age = 0;
			}
			// 根据t1的大小分配内存
			m_pname = new char[strlen(obj.m_pname + 1)];
			// copy t1的数据
			strcpy(m_pname, obj.m_pname);
			m_age = obj.m_age;
			return *this;
		}
	private:
		char* m_pname;
		int m_age;
}
void main(){
	Teacher t1("t1", 31);
	vector<Teacher> v1;
	v1.push_back(t1); // 把t1拷贝了一份存入到v1中，容器中存的那个t1的m_pname和外面的t1的m_pname地址是一样的，析构的时候会析构两次，所以会出错
}

deque使用场景：比如排队购票系统，对排队者的存储可以用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢
vector.at()比deque.at()效率高，vector.at(0)是固定的，deque的开始位置是不固定的
如果有大量释放操作，vector花的时间更少，这跟二者的内部实现有关
deque支持头部的快速插入与快速移除

list的使用场景：公交车乘客的存储，随时有乘客下车，支持频繁的不确定位置的元素的移动插入
set的使用场景：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列
map的使用场景：比如按ID号存储十万个用户，想要快速通过ID查找对应的用户，二叉树的查找效率这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历整个容器才能找到该用户

=================================
算法由头文件algorithm numeric functional组成
算法分类
操作对象：
	直接改变容器内容
	将原容器的内容复制一份，修改其副本，然后传回该副本
功能：
	非可变序列算法：不直接修改其所操作容器内容的算法
		计数算法：count count_if
		搜索算法：search find find_if find_first_of
		比较算法：equal mismatch lexicographical_compare
	可变序列算法：可以修改它们所操作的容器内容的算法
		删除算法：remove remove_if remove_copy
		修改算法：for_each transform
		排序算法：sort stable_sort partial_sort
	排序算法：
		包括对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作
	数值算法：
		对容器内容进行数值计算

函数对象：重载了函数调用操作符的类
template<typename T>
class ShowElement{
	public:
		ShowElement(){
			n = 0;
		}
		void operator()(T& t){
			n++;
			cout << t << " ";
		}
		void printN(){
			cout << n << endl;
		}
	private:
		int n;
}

template <typename T>
void FuncShowElemt(T& t){
	cout << t << endl;
}

void FuncShowElemt2(int& t){
	cout << t << endl;
}
void main(){
	ShowElement<int> showElement;
	int a = 1;
	showElement(a); // 函数对象的执行非常像一个函数，所以又叫仿函数
	
	FuncShowElemt<int>(a);
	
	FuncShowElemt2(a);
	
	// 函数对象是属于类对象，能突破函数的概念，negligence保持调用状态信息
	vector<int> v;
	v1.push_back(1);
	v1.push_back(2);
	v1.push_back(3);
	
	// 匿名函数对象 匿名仿函数
	for_each(v1.begin(), v1.end(), ShowElement<int>());
	// 通过回调函数 谁使用for_each谁去填写回调函数的入口地址
	for_each(v1.begin(), v1.end(), FuncShowElemt2);
	
	ShowElement show1;
	// 函数对象做函数参数
	// 注意这里的形参_Fnc是个元素而不是引用，因此show1传进去之后不管改成什么样，和外面的show1没有关系
	// 但我们注意到函数的返回值也是_Fn1，因此我们可以在外面用show1接一下它的返回值就可以看到show1里面的n属性改变的效果了
	// template<class _Init, class _Fn1> inline
	// _Fn1 for_each(_Init _First, _Init _Last, _Fn1 _Fnc){
	// 	_DEBUG_RANGE(_First, _Last);
	// 	_DEBUG_POINTER(_Func);
	// 	return (_For_each(_Unchecked(_First), _Unchecked(_Last), _Func));
	// }
	for_each(v1.begin(), v1.end(), show1);
	show1.printN(); // 0
	
	ShowElement show2;
	show2 = for_each(v2.begin(), v2.end(), show2);
	show2.printN(); // 3
}

一元谓词===========================
template<typename T>
class IsDiv{
	public:
		T divisor;
		IsDiv(const T& divisor){
			this->divisor = divisor;
		}
		bool operator()(T& t){
			return t % divisor == 0;
		}
}
void main(){
	vector<int> v2;
	for(int i = 10; i < 33; i++){
		v2.push_back(i);
	}
	int a = 4;
	// myDiv对象就是一个谓词
	IsDiv<int> myDiv(a);
	
	find_if(v2.begin(), v2.end(), myDiv);
	// 或者写成
	vector<int>::iterator it;
	// find_if返回一个迭代器
	it = find_if(v2.begin(), v2.end(), IsDiv<int>(a));
	if (it == v2.end()){
		cout << "容器中没有值是4的倍数的元素" << endl;
	} else {
		cout << "第一个被4整除的元素是" << *it << endl;
	}
}

二元函数对象和二元谓词=============
// 二元函数对象
template<typename T>
class SumAdd{
	public:
		T operator()(T t1, T t2){
			return t1 + t2;
		};
	private:
		
}
void main(){
	vector<int> v1, v2;
	vector<int> v3;
	
	v1.push_back(1);
	v1.push_back(3);
	v1.push_back(5);
	
	v2.push_back(1);
	v2.push_back(3);
	v2.push_back(5);
	
	v3.resize(10);
	
	// 返回v3的迭代器的开始位置
	transform(v1.begin(), v1.end(), v2.begin(), v3.begin(), SumAdd<int>());
	
	for(vector<int>::iterator it = v3.begin(); it != v3.end(); it++){
		cout << *it << endl; // 2 6 10 将v1和v2的各项加起来放到v3中
	}
}
// 二元谓词
bool MyCompare(const int& a, const int& b){
	return a < b; // 从小到大
}
void main(){
	vector<int> v(10);
	for(int i = 0; i < 10; i++){
		int tmp = rand() % 100;
		v[i] = tmp;
	}
	for(vector<int>::iterator it = v.begin(); it != v.end(); it++){
		cout << *it << endl;
	}
	for_each(v1.begin(), v1.end(), FuncShowElemt2);
	// MyCompare是二元谓词
	sort(v1.begin(), v1.end(), MyCompare);
	for_each(v1.begin(), v1.end(), FuncShowElemt2);
}
// 二元谓词在set集合中的应用
struct CompareNoCase{
	bool operator()(const string& str1, const string& str2){
		string str1_;
		str1_.resize(str1.size());
		transform(str1.begin(), str1.end(), str1_.begin(), tolower); // 预定义函数对象
		
		string str2_;
		str2_.resize(str2.size());
		transform(str2.begin(), str2.end(), str2_.begin(), tolower);
		return str1_ < str2_; // 从小到大进行排序
	}
}
void main(){
	set<string> set1;
	set1.insert("bbb");
	set1.insert("aaa");
	set1.insert("ccc");
	
	set<string>::iterator it = set1.find("aaa");
	if (it == set1.end()) {
		cout << "没有找到aaa" << endl;
	} else {
		cout << "查找到aaa" << endl;
	}
	
	set<string, CompareNoCase> set2;
	set2.insert("bbb");
	set2.insert("aaa");
	set2.insert("ccc");
	
	set<string, CompareNoCase>::iterator it2 = set2.find("aAa");
	if(it2 == set2.end()){
		cout << "没有找到aaa" << endl;
	} else {
		cout << "查找到aaa" << endl;
	}
}
预定义函数对象和函数适配器=======================
#include <algorithm>
#include "functional"

void main(){
	// plus<int> 是预定义好的函数对象，能实现不同类型的数据运算
	// 实现了数据类型和算法的分离 通过函数对象实现的
	// 思考：怎么样知道plus<type>是两个参数？通过源代码可以找到
	plus<int> intAdd;
	int x = 10;
	int y = 20;
	int z = intAdd(x, y);
	cout << z << endl;
	
	plus<string> stringAdd;
	string s1 = "aaa";
	string s2 = "bbb";
	string s3 = stringAdd(s1, s2);
	cout << s3 << endl;
	
	vector<string> v1;
	v1.push_stack("bbb");
	v1.push_stack("aaa");
	v1.push_stack("ccc");
	v1.push_stack("ccc");
	v1.push_stack("ccc");
	v1.push_stack("zzz");
	sort(v1.begin(), v1.end(), greater<string>());
	
	for(vector<string>::iterator it = v1.begin(); it != v1.end(); it++){
		cout << *it << endl;
	}
	
	// 求ccc出现的个数
	string sc = "ccc";
	// equal_to<string>()有两个参数，左参数来自容器，右参数来自sc
	// bind2nd就是函数适配器，把预定义函数对象和第二个参数进行绑定
	int num = count_if(v1.begin(), v1.end(), bind2nd(equal_to<string>(), sc));
	cout << num << endl;
}

STL中已经定义了大量的函数对象，但是有时候需要对函数返回值进行进一步的简单计算，或者填上多余的参数，不能直接代入算法，函数适配器实现了这一功能，将一种函数对象转化为另一种符合要求的函数对象。函数适配器可以分为4大类，绑定适配器(bind adaptor)、组合适配器(composite adapter)、(指针函数适配器pointer function adapter)和成员函数适配器(member function adaptor)

绑定适配器、组合适配器用的较多
class IsGreat{
	public:
		IsGreat(int i){
			m_num = i;
		};
		bool operator()(int& num){
			if (num > m_num) {
				return true;
			}
			return false;
		}
	private:
		int m_num;
};
void main(){
	vector<int> v1;
	for (int i = 0; i < 10; i++) {
		v1.push_back(i + 1);
	}
	for (vector<int>::iterator it = v1.begin(); it != v1.end(); it++){
		cout << *it << endl;
	}
	
	int num1 = count(v1.begin(), v1.end(), 3); // 1 值为3的个数
	
	// 通过谓词求大于2的个数
	// IsGreat(2)这样一写就会自动调用bool operator()(int& num){这个构造函数，并将2传给num
	int num2 = count_if(v1.begin(), v1.end(), IsGreat(2));
	
	// 通过预定义的函数对象
	//template<class _Ty>
	//struct greater:public binary_function<_Ty, _Ty, bool>{
	//	bool operator()(const _Ty& _Left, const _Ty& _Right) const{
	//		return (_Left > _Right);
	//	}
	//}
	// greater<int>()有两个参数，左参数来自容器的元素，右参数固定为2(通过bind2nd来做的)
	int num3 = count_if(v1.begin(), v1.end(), bind2nd(greater<int>(), 2));
	
	// 求奇数的个数
	int num4 = count_if(v1.begin(), v1.end(), bind2nd(modulus<int>(), 2));
	
	// 求偶数的个数
	int num5 = count_if(v1.begin(), v1.end(), not(bind2nd(modulus<int>(), 2)));
}

STL容器算法迭代器设计理念
1、STL的容器通过类模板技术实现数据类型和容器模型的分离
2、STL的迭代器技术实现了遍历容器的统一方法，也为STL的算法提供了统一性奠定了基础
3、STL的算法通过函数对象实现了自定义数据类型的算法运算，所以说，STL的算法也提供了统一性
	核心思想：其实函数对象本质就是回调函数，回调函数的思想：任务的编写者和任务的调用者有效解耦合，函数指针做函数参数
4、具体例子：transform算法的输入，通过迭代器first和last指向的元素作为输入，通过result作为输出，通过函数对象来做自定义数据类型的运算。
template<class InputIterator, class OutputIterator, class UnaryFunction>
OutputIterator transform(InputIterator first, InputIterator last, OutputIterator result, UnaryFunction op){
	for(;first != last; ++first,++result){
		*result = op(*first);
	}
	return result;
}

STL算法分类
查找算法：adjacent_find() binary_search() count() count_if() equal_range() find() find_if()
排序算法：merge() sort() random_shuffle() reverse()
拷贝和替换算法：copy() replace() replace_if() swap()
算术和生成算法：accumulate() fill()
集合算法：set_union() set_intersection() set_difference()
遍历算法：for_each() transform()

for_each和transform算法基本使用====================
void printV(vector<int> &v){
	for(vector<int>::iterator it = v.begin(); it != v.end(); it++){
		cout << *it << endl;
	}
}
void showElement(int& n){
	cout << n << " ";
}
class CMyShow{
	public:
		CMyShow(){
			num = 0;
		}
		void operator()(int& n){
			num++;
			cout << n << endl;
		}
		void printNum(){
			cout << num << endl;
		}
	private:
		int num;
}
int increase(int i){
	return i + 100;
}
void printList(list<int>& v){
	for(vector<int>::iterator it = v.begin(); it != v.end(); it++){
		cout << *it << endl;
	}
}
void main(){
	vector<int> v1;
	v1.push_back(1);
	v1.push_back(2);
	v1.push_back(3);
	// 函数对象做参数
	for_each(v1.begin(), v1.end(), showElement);
	// 返回值也是一个函数对象
	for_each(v1.begin(), v1.end(), CMyShow());
	
	CMyShow mya;
	CMyShow my1 = for_each(v1.begin(), v1.end(), mya);
	my1.printNum(); // 3
	mya.printNum(); // 0
	// my1和mya是两个不一样的对象
	
	// transform用法==================================
	// 第三个参数v1.begin()是把运算后的结果还放在v1中
	// increase是回调函数
	transform(v1.begin(), v1.end(), v1.begin(), increase);
	
	// 使用预定义的函数对象
	transform(v1.begin(), v1.end(), v1.begin(), negate<int>());
	
	// 使用函数适配器和函数对象
	list<int> mylist;
	mylist.resize(v1.size());
	transform(v1.begin(), v1.end(), v1.begin(), bind2nd(multiplies<int>(), 10));
	printList(mylist);
	
	// transform也可以把运算结果直接输出到屏幕
	// 适配器方法的参数分别为输出流对象和各项之间的间隔符
	transform(v1.begin(), v1.end(), ostream_iterator<int>(cout, " "), negate<int>());
	
	// transform和foreach的区别==========================
	for_each(v1.begin(), v1.end(), showElem);
	// 以下代码编译不通过，transform要求回调函数要有返回值，而showElem返回值为void
	// 需要通过源码查看transform对回调到底有什么要求
	transform(v2.begin(), v2.end(), v2.begin(), showElem);
	
	// 结论：
	// for_each所使用的函数对象，参数是引用，没有返回值
	// transform所使用的函数对象，参数一般不使用引用，而且还有返回值
	// for_each速度快，但不灵活
	// transform速度慢，但是使用灵活
}
bool GreaterThree(int iNum){
	return iNum > 3;
}
// 查找算法==================
void main(){
	vector<int> v1;
	v1.push_back(1);
	v1.push_back(2);
	v1.push_back(3);
	v1.push_back(4);
	v1.push_back(5);
	
	vector<int>::iterator it = adjacent_find(v1.begin(), v1.end());
	if (it == v1.end()) {
		cout << "没找到" << endl;
	} else {
		// 值
		cout << *it << endl;
	}
	// 下标
	int index = distance(v1.begin(), it);
	cout << index << endl;
	
	// binary_search() 二分查找，如果不是排序好的不能用，返回布尔值代表是否找到
	bool b = binary_search(v1.begin(), v1.end(), 7);
	
	// 查找值为7的元素个数
	int num = count(v1.begin(), v1.end(), 7);
	
	// 查找大于3的元素个数
	int num = count_if(v1.begin(), v1.end(), GreaterThree);
	
	// 查找5出现的位置
	vector<int>::iterator it = find(v1.begin(), v1.end(), 5);
	
	// 查找第一个大于3的位置
	vector<int>::iterator it2 = find_if(v1.begin(), v1.end(), GreaterThree);
}

// 排序算法=====================
class Student{
	
}
bool CompareS(Student& s1, Student& s2){
	return s1.m_id < s2.m_id;
}
bool greaterThan5(int& n){
	return n >= 5;
}
void main(){
	vector<int> v1;
	v1.push_back(1);
	v1.push_back(3);
	v1.push_back(5);
	
	vector<int> v2;
	v2.push_back(2);
	v2.push_back(4);
	v2.push_back(6);
	
	vector<int> v3;
	v3.resize(v1.size() + v2.size());
	
	merge(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin());
	
	// sort方法
	vector<Student> v1;
	Student s1("aaa", 1);
	Student s2("bbb", 2);
	Student s3("ccc", 3);
	v1.push_back(s3);
	v1.push_back(s2);
	v1.push_back(s1);
	sort(v1.begin(), v1.end(), CompareS);
	
	// random_shuffle方法 随机排序
	random_shuffle(v1.begin(), v1.end());
	
	string str = "abcdefg";
	random_shuffle(str.begin(), str.end());
	
	// reverse倒序
	reverse(v1.begin(), v1.end());
	
	// copy 将v1拷贝到v2中
	// 注意，拷贝之前v2必须要先分配空间才可以
	vector<int> v2;
	v2.resize(v1.size());
	copy(v1.begin(), v1.end(), v2.begin());
	
	// replace
	replace(v1.begin(), v1.end(), 3, 8); // 将所有值为3的改成8
	
	// 将大于5的项都改成1
	replace(v1.begin(), v1.end(), greaterThan5, 1);
	
	// swap
	swap(v1, v2);
	
	// accumulate 将v1.begin()到v1.end()之间的数字求和再加上100
	int sum = accumulate(v1.begin(), v1.end(), 100);
	
	// fill 将输入值赋给标志范围内所有元素
	fill(v1.begin(), v1.end(), 8); // begin到end之间的元素都将变成8
	
	// set_union
	vector<int> v3;
	v3.resize(v1.size() + v2.size());
	// 求v1和v2的并集，放到v3中
	set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin());
}

演讲比赛综合案例==================
24人参加，三轮比赛，前两轮淘汰赛，第三轮为决赛
分组比赛，每组6人，选手每次随机分组，进行比赛
第一轮分4个组，每组6人，每人分别按抽签顺序演讲，当小组演讲完后，淘汰组内排名最后的3个选手，然后继续下个小组比赛
第二轮分2个组，每组6人，比赛完后依然淘汰最后三名，继续下个小组
第三轮只剩下6个人，选出前三名
共10个评委评分，去除最高最低，求平均
将选手得分进行排列，如果分数一样则按照参赛号排列
要求：
1、打印所有选手的名字和参赛号，并以参赛号升序排列
2、打印每一轮比赛后小组比赛成绩和晋级名单
3、打印决赛前三名，选手名称，成绩

class Speaker{
	public:
	private:
		string m_name;
		int m_score[3];
}
// 产生选手
int GenSpeaker(map<int, Speaker>& mapSpeaker, vector<int>& v){
	string str = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	random_shuffle(str.begin(), str.end());
	
	for(int i = 0; i < 24; i++){
		Speaker tmp;
		tmp.m_name = "选手";
		tmp.m_name = tmp.m_name + str[i];
		mapSpeaker.insert(pair<int, Speaker>(100 + i, tmp));
	}
	// 参赛人员
	for(int i = 0; i < 24; i++){
		v.push_back(100 + i);
	}
	return 0;
}
// 抽签
int speech_contest_draw(vector<int>& v){
	random_shuffle(v.begin(), v.end());
	return 0;
}
// 比赛
int speech_contest(int index, vector<int>& v1, map<int, Speaker>& mapSpeaker, vector<int>& v2){
	// 小组的比赛得分记录下来，求出前三名和后三名
	multimap<int, int, greater<int>> multimapGroup;
	int tmpCount = 0;
	
	for(vector<int>::iterator it = v1.begin(); it != v1.end(); it++){
		tmpCount++;
		{
			deque<int> dscore;
			for(int j = 0; j < 10; j++){
				int score = 50 + random() % 50;
				dscore.push_back(score);
			}
			sort(dscore.begin(), dscore.end());
			dscore.pop_back(); // 去除最高分
			dscore.pop_front(); // 去除最低分
			
			// 求平均分
			int scoresum = accumulate(dscore.begin(), dscore.end(), 0);
			int scoreavg = scoresum / dscore.size();
			
			mapSpeaker[*it].m_score[index] = scoreavg;
			
			multimapGroup.insert(pair<int, int>(scoreavg, *it));
		}
		// 处理分组
		if(tmpCount % 6 == 0)
		{
			cout << "小组的比赛成绩：" << endl;
			for(multimap<int, int, greater<int>>::iterator mit = multimapGroup.begin(); mit != multimapGroup.end(); mit++){
				cout << mit->second << " " << mapSpeaker[mit->second].m_name << " " << mit->first << endl;
			}
			
			// 前三名晋级
			while(multimapGroup.size() > 3){
				multimap<int, int, greater<int>>::iterator it1 = multimapGroup.begin();
				v2.push_back(it1->second); // 把前三名放到v2晋级名单中
				multimapGroup.erase(it1);
			}
			
			multimapGroup.clear(); // 清空本小组比赛成绩
		}
	}
	return 0;
}
// 查看比赛结果
int speech_contest_print(int index, vector<int>& v, map<int, Speaker>& mapSpeaker){
	cout << "第" << index + 1 << "轮晋级名单";
	for(vector<int>::iterator it = v.begin(); it != v.end(); it++){
		cout << *it << " " << mapSpeaker[*it].m_name << mapSpeaker[*it].m_score[index] << endl;
	}
	return 0;
}
void main(){
	// map容器放所有选手
	map<int, Speaker> mapSpeaker;
	vector<int> v1; // 第一轮演讲比赛名单
	vector<int> v2; // 第二轮演讲比赛名单
	vector<int> v3; // 第三轮演讲比赛名单
	vector<int> v4; // 最后的前三名演讲比赛名单
	// 生成第一轮选手名单，放到v1中
	GenSpeaker(mapSpeaker, v1);
	// 第一轮
	// 抽签
	speech_contest_draw(v1);
	// 比赛
	speech_contest(0, v1, mapSpeaker, v2);
	// 查看比赛结果
	speech_contest_print(0, v2, mapSpeaker);
	
	// 第二轮
	speech_contest_draw(v2);
	speech_contest(0, v2, mapSpeaker, v3);
	speech_contest_print(1, v3, mapSpeaker);
	
	// 第三轮
	speech_contest_draw(v3);
	speech_contest(0, v3, mapSpeaker, v4);
	speech_contest_print(2, v4, mapSpeaker);
}


数据结构===============================================================
存储结构分为4大类：顺序存储 链式存储 索引 散列

线性表顺序存储设计与实现
typedef struct SeqList{
	int length;
	int capacity;
	// unsigned int array[capacity]; 定义数组时[]里面必须是一个具体的值，但是这里不能写成一个具体的值，因为分配多少内存空间是由调用者决定的，所以此时就需要动态内存分配
	unsigned int *node;
}SeqList;
SeqList* SeqList_Create(int capacity){
	int ret = 0;
	SeqList* tmp = NULL;
	tmp = (SeqList*)malloc(sizeof(SeqList));
	if (tmp == NULL) {
		ret = -1;
		return NULL;
	}
	memset(tmp, 0, sizeof(SeqList));
	tmp->node = (unsigned int *)malloc(sizeof(unsigned int*) * capacity);
	if (tmp->node == NULL) {
		ret = -2;
		return NULL;
	}
	tmp->capacity = capacity;
	tmp->length = 0;
	return tmp;
}
void SeqList_Destroy(SeqList* list){
	SeqList* tlist = NULL;
	if (list == NULL) {
		return;
	}
	tlist = (SeqList*)list;
	if (tlist -> node != NULL) {
		free(tlist -> node);
	}
	free(tlist);	
}
void SeqList_Clear(SeqList* list){
	SeqList* tlist = NULL;
	if (list == NULL) {
		return;
	}
	tlist = (SeqList*)list;
	tlist -> length = 0;
	return 0;
}
int SeqList_Length(SeqList* list){
	SeqList* tlist = NULL;
	if (list == NULL) {
		return -1;
	}
	tlist = (SeqList*)list;
	return tlist -> length;
}
int SeqList_Capacity(SeqList* list){
	SeqList* tlist = NULL;
	if (list == NULL) {
		return -1;
	}
	tlist = (SeqList*)list;
	return tlist -> capacity;
}
int SeqList_Insert(SeqList* list, SeqListNode* node, int pos){
	int i, ret = 0;
	SeqList* tlist = list;
	if (tlist == NULL || pos < 0) {
		ret = -1;
		return ret;
	}
	tlist = (SeqList*)list;
	// 判断是不是满了
	if (tlist -> length >= tlist -> capacity) {
		ret = -2;
		return ret;
	}
	// 容错修正
	if (pos >= tlist -> length) {
		pos = tlist -> length;
	}
	for(i = tlist -> length; i > pos; i--){
		tlist -> node[i] = tlist -> node[i - 1];
	}
	tlist -> node[i] = (unsigned)node;
	tlist -> length++;
	return ret;
}
SeqListNode* SeqList_Get(SeqList* list, int pos){
	SeqList* tlist = list;
	if (tlist == NULL || pos < 0) {
		return NULL;
	}
	
	return tlist -> node[pos];
}
SeqListNode* SeqList_Delete(SeqList* list, int pos){
	SeqList* tlist = list;
	SeqListNode* ret = NULL;
	int i;
	if (tlist == NULL || pos < 0) {
		return NULL;
	}
	// 先将要删的节点缓存
	ret = (SeqListNode*)tlist -> node[pos];
	// 将删除节点后的所有节点向前移动
	for (i = pos + 1; i < tlist -> length; i++){
		tlist -> node[i - 1] = tlist -> node[i];
	}
	tlist -> length--;
	return ret;
}
// 先看如何使用
typedef struct Teacher{
	int age;
	char name[64];
}Teacher;
void main(){
	int i = 0;
	int ret = 0;
	// 创建线性表
	SeqList* list = NULL;
	Teacher t1, t2, t3, t4, t5;
	t1.age = 31;
	t2.age = 31;
	t3.age = 31;
	t4.age = 31;
	t5.age = 31;
	
	list = SeqList_Create(10);
	if (list == NULL) {
		printf("error");
	}
	
	// 内部不会关心插入的节点类型是什么
	ret = SeqList_Insert(list, (SeqListNode*)&t1, 0);
	ret = SeqList_Insert(list, (SeqListNode*)&t2, 0);
	ret = SeqList_Insert(list, (SeqListNode*)&t3, 0);
	ret = SeqList_Insert(list, (SeqListNode*)&t4, 0);
	ret = SeqList_Insert(list, (SeqListNode*)&t5, 0);
	
	for(i = 0; i < SeqList_Length(list); i++){
		Teacher* tmp = (Teacher*) SeqList_Get(list, i);
		if (tmp == NULL) {
			return;
		}
		printf(tmp->age);
	}
	
	// 删除节点
	while(SeqList_Length(list) > 0){
		SeqList_Destroy(list, 0);
	}
}

线性表的链式存储和实现==================================
这里的链表和之前的链表有很大不同，此处链表将算法和具体业务进行了分离
之前的链表有一个指针域，指向同类型的一个节点，但是这种链表并不具有通用性，仅仅适合特定类型节点的场合
我们现在要实现的链表中的每个业务节点不会和实现链表本身的节点产生耦合关系，实现链表本身的节点可以继续扩展其他功能，例如可以实现双向链表，实现循环链表等等，而无需对具体的业务节点结构体做任何的改变
由此我们可以发现，实现链表本身的节点专门用来在内部扩展各种方法，业务节点直接将其包含进去使用即可
linklist.h================
#ifndef _MYLINKLIST_H_
#define _MYLINKLIST_H_

typedef void LinkList;

typedef struct _tag_LinkListNode{
	struct _tag_LinkListNode* next;
}LinkListNode;

LinkList* LinkList_Create();
void LinkList_Destroy(LinkList* list);
void LinkList_Clear(LinkList* list);
int LinkList_Length(LinkList* list);
int LinkList_Insert(LinkList* list, LinkListNode* node, int pos);
LinkListNode* LinkList_Get(LinkList* list, int pos);
LinkListNode* LinkList_Delete(LinkList* list, int pos);

#endif
实现文件===============
// 
LinkList* LinkList_Create(){
	TLinkList* ret = NULL;
	
	ret = (TLinkList*)malloc(sizeof(TLinkList));
	memset(ret, 0, sizeof(TLinkList));
	ret -> length = 0;
	ret -> header.next = NULL;
	
	return ret;
}
void LinkList_Destroy(LinkList* list){
	if (list != NULL) {
		free(list);
		list = NULL;
	}
	return;
}
void LinkList_Clear(LinkList* list){
	TLinkList* tlist = NULL;
	if (list == NULL) {
		return;
	}
	tlist = (TLinkList*)list;
	tlist -> length = 0;
	tlist -> header.next = NULL;
}
int LinkList_Length(LinkList* list){
	TLinkList* tlist = NULL;
	if (list == NULL) {
		return -1;
	}
	tlist = (TLinkList*)list;
	return tlist -> length;
}
int LinkList_Insert(LinkList* list, LinkListNode* node, int pos){
	TLinkList* tlist = NULL;
	int i = 0;
	LinkListNode* t = NULL;
	if (list == NULL) {
		return -1;
	}
	if (node == NULL) {
		return -2;
	}
	if (pos < 0) {
		return -3;
	}
	tlist = (TLinkList*)list;
	t = &(tlist -> header);
	for (i = 0; i < pos && (t -> next != NULL); i++) {
		t = t -> next;
	}
	node -> next = t -> next;
	t -> next = node;
	tlist -> length++;
	return 0;
}
LinkListNode* LinkList_Get(LinkList* list, int pos){
	TLinkList* tlist = NULL;
	LinkListNode* t = NULL;
	int i = 0;
	
	if (list == NULL) {
		return -1;
	}
	if (pos < 0) {
		return -3;
	}
	tlist = (TLinkList*)list;
	t = &(tlist -> header);
	for (i = 0; i < pos && (t -> next != NULL); i++) {
		t = t -> next;
	}
	return t;
}
LinkListNode* LinkList_Delete(LinkList* list, int pos){
	TLinkList* tlist = NULL;
	int i = 0;
	LinkListNode* t = NULL;
	LinkListNode* del = NULL;
	if (list == NULL) {
		return -1;
	}
	if (node == NULL) {
		return -2;
	}
	if (pos < 0) {
		return -3;
	}
	tlist = (TLinkList*)list;
	t = &(tlist -> header);
	for (i = 0; i < pos && (t -> next != NULL); i++) {
		t = t -> next;
	}
	
	del = t -> next;
	t -> next = t -> next -> next;
	tlist -> length--;
	return del;
}
typedef struct _tag_LinkList{
	LinkListNode header;
	int length;
}TLinkList;
typedef struct Teacher{
	// 注意该节点必须放在结构体的第一个位置
	LinkListNode node;
	int age;
	char name[64];
}Teacher
void main(){
	int len = 0;
	int ret = 0;
	LinkList* list = NULL;
	Teacher t1, t2, t3, t4, t5;
	t1.age = 31;
	t2.age = 32;
	t3.age = 33;
	t4.age = 34;
	t5.age = 35;
	
	list = LinkList_Create();
	
	if (list == NULL) {
		return;
	}
	
	len = LinkList_Length(list);
	
	ret = LinkList_Insert(list, LinkListNode*(&t1), 0);
	ret = LinkList_Insert(list, LinkListNode*(&t2), 0);
	ret = LinkList_Insert(list, LinkListNode*(&t3), 0);
	ret = LinkList_Insert(list, LinkListNode*(&t4), 0);
	ret = LinkList_Insert(list, LinkListNode*(&t5), 0);
	
	// 遍历
	for (i = 0; i < LinkList_Length(list); i++) {
		Teacher* tmp = (Teacher*)LinkList_Get(list, i);
		if (tmp == NULL) {
			return;
		}
		printf(tmp -> age);
	}
	
	// 删除链表
	while (LinkList_Length(list) > 0) {
		LinkList_Delete(list, 0);
	}
}

// 循环链表=================
循环链表增加了游标的概念，可以通过游标遍历链表中所有元素
游标相关算法有重置游标到第一个元素
获取当前游标指向的数据元素
将游标移动指向到链表中的下一个数据元素
直接指定删除链表中的某个数据元素
circlelinklist.h
#ifdef _MYCIRCLELINKLIST_H_
#define _MYCIRCLELINKLIST_H_

typedef void CircleLinkList;

typedef struct _tag_CircleLinkListNode{
	struct _tag_CircleLinkListNode* next;
}

CircleLinkList* CircleLinkList_Create();
void CircleLinkList_Destroy(CircleLinkList* list);
void CircleLinkList_Clear(CircleLinkList* list);
int CircleLinkList_Length(CircleLinkList* list);
int CircleLinkList_Insert(CircleLinkList* list, CircleLinkListNode* node, int pos);
CircleLinkListNode* CircleLinkList_Get(CircleLinkList* list, int pos);
CircleLinkListNode* CircleLinkList_Delete(CircleLinkList* list, int pos);
// 循环链表新增的方法
// 将游标重置指向链表中的第一个数据元素
CircleLinkListNode* CircleLinkList_Reset(CircleLinkList* list);
// 获取当前游标指向的元素
CircleLinkListNode* CircleLinkList_Current(CircleLinkList* list);
// 将游标移动指向到链表中的下一个数据元素
CircleLinkListNode* CircleLinkList_Next(CircleLinkList* list);
// 指定删除链表中某个数据元素
CircleLinkListNode* CircleLinkList_DeleteNode(CircleLinkList* list, CircleLinkListNode* node);
#endif

实现文件=================================
typedef struct TCircleLinkList{
	CircleLinkListNode header;
	// 新增了游标
	CircleLinkListNode* slider;
	int length;
}TCircleLinkList;
typedef struct Teacher{
	CircleLinkListNode node;
	int age;
	char name[64];
}Teacher;
CircleLinkList* CircleLinkList_Create(){
	TCircleLinkList* list = NULL;
	
	list = (TCircleLinkList*)malloc(sizeof(TCircleLinkList));
	if (list == NULL) {
		return NULL;
	}
	memset(list, 0, sizeof(TCircleLinkList));
	
	list -> length = 0;
	// 初始化头指针为NULL
	list -> header.next = NULL;
	// 初始化游标
	list -> slider = NULL;
	
	return list;
}
void CircleLinkList_Destroy(CircleLinkList* list){
	if (list == NULL) {
		return;
	}
	free(list);
	list = NULL;
}
void CircleLinkList_Clear(CircleLinkList* list){
	TCircleLinkList* tlist = NULL;
	if (list == NULL) {
		return;
	}
	tlist = (TCircleLinkList*)list;
	tlist -> length = 0;
	tlist -> header.next = NULL;
	tlist -> slider = NULL;
}
int CircleLinkList_Length(CircleLinkList* list){
	TCircleLinkList* tlist = NULL;
	if (list == NULL) {
		return -1;
	}
	tlist = (TCircleLinkList*)list;
	return tlist -> length;
}
int CircleLinkList_Insert(CircleLinkList* list, CircleLinkListNode* node, int pos){
	TCircleLinkList* tlist = NULL;
	CircleLinkListNode* tmpnode = NULL;
	int i = 0;
	
	if (list == NULL || node == NULL || pos < 0) {
		return -1;
	}
	tlist = (TCircleLinkList*)list;
	tmpnode = &(tlist -> header);
	
	for (i = 0; i < pos && tmpnode -> next != NULL; i++) {
		tmpnode = tmpnode -> next;
	}
	node -> next = tmpnode -> next;
	tmpnode -> next = node;
	// 如果是第一次插入节点
	if (tlist -> length == 0){
		tlist -> slider = node;
	}
	tlist -> length++;
	// 如果是头插法 tmpnode仍然指向头部
	// (CircleLinkListNode*)tlist将整个链表tlist转为一个节点类型，则为该链表的第一个节点，即头结点
	// 所谓头插法其实就是在0号位置插入元素：CircleLinkList_Insert(tlist, node, 0);比较特殊的情况是插入第1个节点时的情况，插入第一个节点时是最复杂的，因为第一个节点需要将待插入的节点指向游标节点，同时也是头插的场景
	if (tmpnode == (CircleLinkListNode*)tlist){
		// 在最开头插入节点时，在上述工作完成后会发现新插入的节点并没有在环当中，因为头结点是不在环中的，因此新节点插入完了之后仅仅是和头结点连着，并没有在环当中，此时要手动改变一下最后一个节点的指向，使其指向刚插入的新节点
		CircleLinkListNode* last = CircleLinkList_Get(tlist, tlist -> length - 1);
		last -> next = tmpnode -> node;
	}
	return 0;
}
CircleLinkList* CircleLinkList_Get(CircleLinkList* list, int pos){
	TCircleLinkList* tlist = NULL;
	CircleLinkListNode* tmpnode = NULL;
	int i = 0;
	
	if (list == NULL || pos < 0) {
		return -1;
	}
	tlist = (TCircleLinkList*)list;
	tmpnode = &(tlist -> header);
	
	for (i = 0; i < pos; i++) {
		tmpnode = tmpnode -> next;
	}
	return tmpnode;
}
CircleLinkListNode* CircleLinkList_Delete(CircleLinkList* list, int pos){
	// 我写的
	// TCircleLinkList* tlist = NULL;
	// CircleLinkListNode* tmpnode = NULL;
	// CircleLinkListNode* deletenode = NULL;
	// int i = 0;
	// 
	// if (list == NULL || pos < 0) {
	// 	return -1;
	// }
	// tlist = (TCircleLinkList*)list;
	// tmpnode = &(tlist -> header);
	// 
	// for (i = 0; i < pos; i++) {
	// 	tmpnode = tmpnode -> next;
	// }
	// 
	// deletenode = tmpnode -> next;
	// tmpnode -> next = deletenode -> next;
	// tlist -> length--;
	// 
	// return deletenode;
	
	// 老师写的==========================
	TCircleLinkList* sList = (TCircleLinkList*)list;
	CircleLinkListNode* ret = NULL;
	int i = 0;
	
	CircleLinkListNode* current = (CircleLinkListNode*)sList;
	CircleLinkListNode* last = NULL;
	
	if (sList == NULL || pos < 0 || sList -> length == 0) {
		return NULL;
	}
	
	for (i = 0; i < pos; i++) {
		current = current -> next;
	}
	
	// 如果删除第一个元素
	if (current == (CircleLinkListNode*)sList){
		last = (CircleLinkListNode*)CircleLinkList_Get(sList, sList -> length - 1);
	}
	
	// 求要删除的元素
	ret = current -> next;
	current -> next = ret -> next;
	sList -> length--;
	
	// 判断链表是否为空 在第一次插入的时候last就会是NULL
	if (last != NULL) {
		sList -> header.next = ret -> next;
		last -> next = ret -> next;
	}
	
	// 如果删除的元素为游标所指的元素
	if (sList -> slider == ret) {
		sList -> slider = ret -> next;
	}
	
	// 若删除元素后，链表长度为0
	if (sList -> length == 0) {
		sList -> header.next = NULL;
		sList -> slider = NULL;
	}
}
// 循环链表特有的方法==============
CircleLinkListNode* CircleLinkList_DeleteNode(CircleLinkList* list, CircleLinkListNode* node){
	TCircleLinkList* sList = (TCircleLinkList*)list;
	CircleLinkListNode* ret = NULL;
	int i = 0;
	
	if (sList == NULL) {
		return NULL;
	}
	CircleLinkListNode* current = (CurrentLinkListNode*)sList;
	
	// 查找node在循环链表中的位置
	for (i = 0; i < sList -> length; i++) {
		if (current -> next == node) {
			ret = current -> next;
			break;
		}
		current = current -> next;
	}
	
	// 如果ret找到了，根据i去删除
	if ( ret != NULL) {
		CircleLinkList_Delete(sList, i);
	}
	
	return ret;
}
CircleLinkListNode* CircleLinkList_Reset(CircleLinkList* list){
	TCircleLinkList* sList = (TCircleLinkList*)list;
	CircleLinkListNode* ret = NULL;
	
	if ( sList != NULL ){
		sList -> slider = sList -> header.next;
		ret = sList -> slider;
	}
	return ret;
}
CircleLinkListNode* CircleLinkList_Current(CircleLinkList* list){
	TCircleLinkList* sList = (TCircleLinkList*)list;
	CircleLinkListNode* ret = NULL;
	
	if ( sList != NULL ) {
		ret = sList -> slider;
	}
	return ret;
}
CircleLinkListNode* CircleLinkList_Next(CircleLinkList* list){
	TCircleLinkList* sList = (TCircleLinkList*)list;
	CircleLinkListNode* ret = NULL;
	
	if ( sList != NULL && sList -> slider != NULL){
		ret = sList -> slider;
		sList -> slider = ret -> next;
	}
	return ret;
}

void main(){
	int len = 0;
	int ret = 0;
	int i = 0;
	CircleLinkList* list = NULL;
	Teacher t1, t2, t3, t4, t5;
	Teacher* t;
	
	t1.age = 31;
	t2.age = 32;
	t3.age = 33;
	t4.age = 34;
	t5.age = 35;
	
	list = CircleLinkList_Create();
	if (list == NULL) {
		return;
	}
	
	CircleLinkList_Insert(list, CircleLinkListNode*(&t1), 0);
	CircleLinkList_Insert(list, CircleLinkListNode*(&t2), 0);
	CircleLinkList_Insert(list, CircleLinkListNode*(&t3), 0);
	CircleLinkList_Insert(list, CircleLinkListNode*(&t4), 0);
	CircleLinkList_Insert(list, CircleLinkListNode*(&t5), 0);
	
	len = CircleLinkList_Length(list);
	
	for ( i = 0; i < len; i++) {
		t = (Teacher*)CircleLinkList_Get(list, i);
		if (t == NULL) {
			return;
		}
		printf(t -> age);
	}
	
	while (CircleLinkList_Length(list) > 0) {
		CircleLinkList_Delete(list, 0);
	}
	
}
void main(){	
	// 约瑟夫问题===================
	int i = 0;
	CircleLinkList* list = CircleLinkList_Create();
	Teacher t1, t2, t3, t4, t5, t6, t7, t8;
	
	t1.age = 1; t2.age = 2; t3.age = 3; t4.age = 4;
	t5.age = 5; t6.age = 6; t7.age = 7; t8.age = 8;
	
	CircleLinkList_Insert(list, (CircleLinkListNode*)&t1, CircleLinkList_Length(list));
	CircleLinkList_Insert(list, (CircleLinkListNode*)&t2, CircleLinkList_Length(list));
	CircleLinkList_Insert(list, (CircleLinkListNode*)&t3, CircleLinkList_Length(list));
	CircleLinkList_Insert(list, (CircleLinkListNode*)&t4, CircleLinkList_Length(list));
	CircleLinkList_Insert(list, (CircleLinkListNode*)&t5, CircleLinkList_Length(list));
	CircleLinkList_Insert(list, (CircleLinkListNode*)&t6, CircleLinkList_Length(list));
	CircleLinkList_Insert(list, (CircleLinkListNode*)&t7, CircleLinkList_Length(list));
	CircleLinkList_Insert(list, (CircleLinkListNode*)&t8, CircleLinkList_Length(list));
	
	CircleLinkList_Reset(list);
	
	while(CircleLinkList_Length(list) > 0){
		Teacher* t = NULL;
		for (i = 0; i < 3; i++) {
			CircleLinkList_Next(list);
		}
		t = (Teacher*)CircleLinkList_Current(list);
		printf(t -> age);
		CircleList_Delete(list, (CircleLinkListNode*)t);
	}
	
	CircleLinkList_Destroy(list);
}
双向链表====================================
新操作：
将游标重置指向链表的第一个数据元素
将游标移动指向链表中的下一个数据元素
将游标移动指向链表中的上一个数据元素
// 头文件
#ifdef _MY_DLINKLIST_H_
#define _MY_DLINKLIST_H_

typedef void DLinkList;

typedef struct _tag_DLinkListNode{
	struct _tag_DLinkListNode* next;
	struct _tag_DLinkListNode* prev;
}DLinkListNode;

DLinkList* DLinkList_Create();

void DLinkList_Destroy(DLinkList* list);

void DLinkList_Clear(DLinkList* list);

int DLinkList_Length(DLinkList* list);

int DLinkList_Insert(DLinkList* list, DLinkListNode* node, int pos);

DLinkListNode* DLinkList_Get(DLinkList* list, int pos);

// 以下是双向链表特有的方法============
DLinkListNode* DLinkList_DeleteNode(DLinkList* list, DLinkListNode* node,);

DLinkListNode* DLinkList_Reset(DLinkList* list);

DLinkListNode* DLinkList_Current(DLinkList* list);

DLinkListNode* DLinkList_Next(DLinkList* list);

DLinkListNode* DLinkList_Prev(DLinkList* list);

#endif

实现文件==================
typedef struct _tag_DLinkList{
	DLinkListNode header;
	DLinkListNode* slider;
	int length;
}TDLinkList;
DLinkList* DLinkList_Create(){
	TDLinkList* ret = (TDLinkList*)malloc(sizeof(TDLinkList));
	
	if (ret != NULL) {
		ret -> length = 0;
		ret -> header.next = NULL;
		ret -> header.prev = NULL;
		ret -> slider = NULL;
	}
	return ret;
}
void DLinkList_Destroy(DLinkList* list) {
	if (list != NULL) {
		free(list);
	}
}
void DLinkList_Clear(DLinkList* list) {
	TDLinkList* sList = (TDLinkList*)list;
	if (sList != NULL) {
		sList -> length = 0;
		sList -> header.next = NULL;
		sList -> header.prev = NULL;
		sList -> slider = NULL;
	}
}
int DLinkList_Length(DLinkList* list) {
	TDLinkList* tList = (TDLinkList*)list;
	int ret = -1;
	
	if (sList != NULL) {
		ret = sList -> length;
	}
	
	return ret;
}
int DLinkList_Insert(DLinkList* list, DLinkListNode* node, int pos){
	int ret = 0;
	int i = 0;
	TDLinkList* sList = (TDLinkList*)list;
	
	if ( sList == NULL || node == NULL || pos < 0){
		return -1;
	}
	
	{
		DLinkListNode* current = (DLinkListNode*)sList;
		DLinkList* next = NULL;
		for (i = 0; i < pos && current -> next != NULL; i++) {
			current = current -> next;
		}
		// 插入到尾部的时候next会变成NULL
		next = current -> next;
		
		current -> next = node;
		node -> next = next;
		
		// next不为NULL的情况是排除了尾插法的情况
		if (next != NULL) {
			next -> prev = node;
		}		
		node -> prev = current;
		
		// sList长度为0时，代表插入第一个元素的情况
		if (sList -> length == 0) {
			// 插入第一个元素，处理游标
			sList -> slider = node;
		}
		
		// 在0位置插入的情况（头插法），需要特殊处理，将插入的节点的prev指向NULL
		if (current -> (DLinkListNode*)sList) {
			node -> prev = NULL;
		}
		
		sList -> length++;
	}
	return ret;
}
DLinkListNode* DLinkList_Get(DLinkList* list, int pos){
	TDLinkList* sList = (TDLinkList*)list;
	DLinkListNode* ret = NULL;
	int i = 0;
	
	if (sList != NULL && pos >= 0 && pos < sList -> length){
		DLinkListNode* current = (DLinkListNode*)sList;
		
		for(i = 0; i < pos; i++){
			current = current -> next;
		}
		ret = current -> next;
	}
	return current;
}
DLinkListNode* DLinkList_Delete(DLinkList* list, int pos){
	TDLinkList* sList = (TDLinkList*)list;
	DLinkListNode* ret = NULL;
	int i = 0;
	if (sList == NULL || pos < 0) {
		return NULL;
	}
	
	{
		DLinkListNode* current = (DLinkListNode*)sList;
		DLinkListNode* next = NULL;
		
		for (i = 0; i < pos; i++) {
			current = current -> next;
		}
		ret = current -> next;
		next = ret -> next;
		
		current -> next = next;
		if (next != NULL) {
			next -> prev = current;
			// 如果在第0个位置删除，需要特殊处理
			if (current == (DLinkListNode*)sList) {
				next -> prev = NULL;
			}
		}
		
		// 如果删掉了游标指向的元素，游标应该指向下一个元素
		if (sList -> slider == ret) {
			sList -> slider = next;
		}
		
		sList -> length--;
	}
	return ret;
}
DLinkListNode* DLinkList_DeleteNode(DLinkList* list, DLinkListNode* node){
	TDLinkList* sList = (TDLinkList*)list;
	DLinkListNode* ret = NULL;
	int i = 0;
	
	if (node != NULL) {
		DLinkListNode* current = (DLinkListNode*)sList;
		for (i = 0; i < sList -> length; i++) {
			if (current -> next == node) {
				ret = current -> next;
				break;
			}
			current = current -> next;
		}
		if (ret != NULL) {
			DLinkList_Delete(sList, i);
		}
	}
	return ret;
}
DLinkListNode* DLinkList_Reset(DLinkList* list){
	TDLinkList* sList = (TDLinkList*)list;
	DLinkListNode* ret = NULL;
	
	if (sList != NULL) {
		sList -> slider = sList -> header.next;
		ret = sList -> slider;
	}
	return ret;
}
DLinkListNode* DLinkList_Current(DLinkList* list){
	TDLinkList* sList = (TDLinkList*)list;
	DLinkListNode* ret = NULL;
	
	if (sList != NULL) {
		ret = sList -> slider;
	}
	return ret;
}
DLinkListNode* DLinkList_Prev(DLinkList* list){
	TDLinkList* sList = (TDLinkList*)list;
	DLinkListNode* ret = NULL;
	
	if (sList != NULL && sList -> slider != NULL) {
		ret = sList -> slider.prev;
	}
	return ret;
}
DLinkListNode* DLinkList_Next(DLinkList* list){
	TDLinkList* sList = (TDLinkList*)list;
	DLinkListNode* ret = NULL;
	
	if (sList != NULL && sList -> slider != NULL) {
		ret = sList -> slider.next;
	}
	return ret;
}
int main(){
	int i = 0;
	DLinkList* list = DLinkList_Create();
	struct Value* pv = NULL;
	struct Value v1, v2, v3, v4, v5;
	
	v1.v = 1; v2.v = 2; v3.v = 3; v4.v = 4; v5.v = 5;
	
	DLinkList_Insert(list, (DLinkList*)v1, DLinkList_Length(list));
	DLinkList_Insert(list, (DLinkList*)v2, DLinkList_Length(list));
	DLinkList_Insert(list, (DLinkList*)v3, DLinkList_Length(list));
	DLinkList_Insert(list, (DLinkList*)v4, DLinkList_Length(list));
	DLinkList_Insert(list, (DLinkList*)v5, DLinkList_Length(list));
	
	for(i = 0; i < DLinkList_Length(list); i++){
		pv = (struct Value*)DLinkList_Get(list, i);
		printf(pv -> v);
	}
	
	DLinkList_Delete(list, DLinkList_Length(list) - 1);
	DLinkList_Delete(list, 0);
	
	for(i = 0; i < DLinkList_Length(list); i++){
		pv = (struct Value*)DLinkList_Get(list, i);
		printf(pv -> v);
	}
	
	// 游标重置
	DLinkList_Reset(list);
	// 游标向后指
	DLinkList_Next(list);
	
	pv = (struct Value*)DLinkList_Current(list);
	printf(pv -> v);
	
	// 传入节点对象删除
	DLinkList_DeleteNode(list, (DLinkListNode*)pv);
	
	pv = (struct Value*)DLinkList_Current(list);
	printf(pv -> v);
	
	// 游标向前指
	DLinkList_Prev(list);
	
	pv = (struct Value*)DLinkList_Current(list);
	printf(pv -> v);
	
	printf(DLinkList_Length(list));
}

// 栈========================
分顺序存储和链式存储
操作：创建 销毁 清空 进栈 出栈 获取栈顶元素 获取栈的大小
// stack.h
#ifdef _MY_STACT_H_
#define _MY_STACT_H_
typedef void Stack;
Stack* Stack_Create(int capacity);
void Stack_Destroy(Stack* stack);
void Stack_Clear(Stack* stack);
int Stack_Push(Stack* stack, void* item);
void* Stack_Pop(Stack* stack);
void* Stack_Top(Stack* stack);
int Stack_Size(Stack* stack);
#endif

// stack.c 线性存储============
#include "stack.h"
#include "list.h"
Stack* Stack_Create(int capacity){
	return List_Create(capacity);
}
void Stack_Destroy(Stack* stack){
	List_Destroy(stack);
}
void Stack_Clear(Stack* stack){
	List_Clear(stack);
}
int Stack_Push(Stack* stack, void* item){
	return List_Insert(stack, item, List_Length(stack));
}
void* Stack_Pop(Stack* stack){
	return List_Delete(stack, List_Length(stack) - 1);
}
void* Stack_Top(Stack* stack){
	return List_Get(stack, List_Length(stack) - 1);
}
int Stack_Capacity(Stack* stack){
	return List_Capacity(stack);
}
int Stack_Size(Stack* stack){
	return List_Length(stack);
}

// stack.c 链式存储=============
// 2个难点：在链表的头部添加删除好还是在链表的尾部添加删除好？
// 在线性表中，是在尾部
// 但是在链表中如果尾部开口，出栈的时候需要从头遍历到尾部，遍历次数太多
// 如果在头部开口，直接干掉第一个元素即可，至于插入节点，采用头插的方式即可，链表的插入操作比较高效
// 难点之二：如何把栈的业务节点转成链表的业务节点 栈是一种特殊的链表，因此我们的处理方式必然是将栈类型的业务节点转成链表类型的业务节点然后将其插入到链表中
#include "stack.h"
#include "linklist.h"
// 栈也是一种特殊的链表，在链表中外部的业务节点是通过一个构造体实现的，其第一个属性链表节点，在此处也同理将第一个属性置为链表节点，第二个属性开始是栈特有的业务节点
typedef struct _tag_LinkStackNode{
	LinkListNode node;
	void* item;
}TStack;
Stack* Stack_Create(){
	return LinkList_Create();
}
void Stack_Destroy(Stack* stack){
	Stack_Clear(stack);
	LinkList_Destroy(stack);
	return;
}
// 清空栈时涉及到栈元素生命周期的管理
// 所有入栈的节点都是malloc出来的，如果要清空栈，要把栈中元素弹出，并释放节点内存
void Stack_Clear(Stack* stack){
	if (stack == NULL) {
		return;
	}
	while(Stack_Size(stack) > 0){
		Stack_Pop(stack); // 这个函数中会释放内存
	}
	return;
}
int Stack_Push(Stack* stack, void* item){
	TStack* tmp = NULL;
	int ret = 0;
	tmp = (TStack*)malloc(sizeof(TStack));
	if (tmp == NULL) {
		return -1;
	}
	memset(tmp, 0, sizeof(TStack));
	tmp -> item = item;
	ret = LinkList_Insert(stack, (LinkListNode*)tmp, 0);
	if (ret != 0) {
		// 有误
		if (tmp != NULL) {
			free(tmp);
		}
		return ret;
	}
	return 0;
}
// 把线性表业务节点转成栈的业务节点
void* Stack_Pop(Stack* stack){
	// 栈的业务节点
	void* item = NULL;
	TLinkStackNode* tmp = NULL;
	tmp = (TLinkStackNode*)LinkList_Delete(stack, 0);
	if (tmp == NULL) {
		return NULL;
	}
	item = tmp -> item;
	// 因为LinkList_Insert的时候分配了内存，所以LinkList_Delete释放内存
	free(tmp);
	return item;
}
// 获取栈顶元素相当于获取线性表的0号位置
void* Stack_Top(Stack* stack){
	TLinkListNode* tmp = NULL;
	tmp = (TLinkListNode*)LinkList_Get(stack, 0);
	if (tmp == NULL) {
		return NULL;
	}
	return tmp -> item;
}
int Stack_Size(Stack* stack){
	return LinkList_Length(stack);
}

// 主文件
#include "stack.h" // 注意是.h文件而不是.c文件
void main(){
	Stack* stack = NULL;
	stack = Stack_Create(10);
	int a[10];
	if (stack == NULL) {
		return;
	}
	for (int i = 0; i < 5; i++) {
		a[i] = i + 1;
		Stack_Push(stack, &a[i]);
	}
	// 求栈的长度 注意链式栈没有该方法
	printf(Stack_Capacity(stack));
	// 求栈的容量
	printf(Stack_Size(stack));
	// 栈顶元素
	printf(*((int *)Stack_Top(stack)));
	
	while(Stack_Size(stack) > 0) {
		printf(*((int*)Stack_Pop(stack)));
	}
}
// 栈的应用
================================
就近匹配：编译器如何匹配成对的括号？
从第一个字符开始扫描
当遇到普通字符时忽略
当遇到左符号时压入栈
当遇见右符号时从栈中弹出栈顶符号，并进行匹配
	匹配成功：基础读入下一个字符
	匹配失败：立即报错
结束：
	成功：所有字符扫描完毕，且栈为空
	失败：匹配失败或所有字符扫描完毕但栈非空

当需要检测成对出现但又互不相邻的事物时可以使用栈后进先出的特性
栈非常适合于需要就近匹配的场合
int isLeft(char c){
	int ret = 0;
	switch(c){
		case '<':
		case '(':
		case '[':
		case '{':
		case '\'':
		case '\"':
			ret = 1;
			break;
		default:
			ret = 0;
			break;
	}
}
int isRight(char c){
	int ret = 0;
	switch(c){
		case '>':
		case ')':
		case ']':
		case '}':
		case '\'':
		case '\"':
			ret = 1;
			break;
		default:
			ret = 0;
			break;
	}
}
int match(char left, char right){
	int ret = 0;
	switch(left){
		case '<':
			ret = (right == '>');
			break;
		case '(':
			ret = (right == ')');
			break;
		case '[':
			ret = (right == ']');
			break;
		case '{':
			ret = (right == '}');
			break;
		case '\'':
			ret = (right == '\'');
			break;
		case '\"':
			ret = (right == '\"');
			break;
		default:
			ret = 0;
			break;
	}
	return ret;
}
int scanner(const char* code){
	Stack* stack = Stack_Create();
	int ret = 0;
	int i = 0;
	
	while(code[i]) {
		if (isLeft(code[i])) {
			Stack_Push(stack, (void*)(code + i)); // &code[i]
		}
		if (isRight(code[i])) {
			char* c = (char*)Stack_Pop(stack);
			if (c == NULL || !match(*c, code[i])) {
				printf("%c doesn't match\n", code[i]);
				ret = 0;
				break;
			}
		}
		i++;
	}
	
	if (Stack_Size(stack) == 0 && code[i] == '\0') {
		printf("success");
		ret = 1;
	} else {
		printf("fail");
		ret = 0;
	}
	
	Stack_Destroy(stack);
	return ret;
}
void main(){
	const char* code = "int arr = a[10];";
}

中缀和后缀，逆波兰表达式============================
5 + 4 符号在中间的表达式叫中缀表达式
5 4 + 复号在后面的表达式叫后缀表达式
中缀转后缀算法：
对于数字：直接输出
对于符号：
	左括号：进栈
	运算符号：与栈顶符号进行优先级比较
		若栈顶符号优先级低：此符合进栈 （栈顶若是左括号，左括号优先级最低）
		若栈顶符号优先级不低：将栈顶符号弹出并输出，之后再让当前符号进栈
	右括号：将栈顶符号弹出并输出，直到匹配左括号
遍历结束：将栈中的所有符号弹出并输出

计算机如何基于后缀表达式运算：
对于数字：进栈
对于符号：
	从栈中弹出右操作数
	从栈中弹出左操作数
	根据符号进行运算
	将运算结果压入栈中
遍历结束：栈中的唯一数字为计算结果

中缀转后缀代码=============================
int priority(char c){
	int ret = 0;
	
	if (c == '+' || c == '-') {
		ret = 1;
	}
	if (c == '*' || c == '/') {
		ret = 2;
	}
	
	return ret;
}
void transform(const char* exp){
	int i = 0;
	Stack* stack = Stack_Create();
	
	while (exp[i] != '\0') {
		if (isNumber(exp[i])) {
			output(exp[i]);
		} else if ( isOperator(exp[i]) ) {
			while( priority(exp[i]) <= priority((char)(int)Stack_Top(stack) ) {
				output((char)(int)Stack_Pop(stack));
			}
			Stack_Push(stack, (void*)(int)exp[i]);
		} else if ( isLeft(exp[i]) ) {
			Stack_Push(stack, (void*)(int)exp[i]);
		} else if ( isRight(exp[i]) ) {
			// 一直出栈，直到遇到左括号
			while( !isLeft((char)(int)Stack_Top(stack)) ){
				output((char)(int)Stack_Pop(stack));
			}
			// 把左括号也从栈中弹出
			Stack_Pop(stack);
		} else {
			printf("Invalid Expression");
			break;
		}
		i++;
	}
	// 扫描完之后把栈中剩下的都弹出来
	while ( Stack_Size(stack) > 0 && exp[i] == '\0' ) {
		output((char)(int)Stack_Pop(stack));
	}
	Stack_Destroy(stack);
}
int main(){
	transform("8+(3-1)*5");
}

后缀计算代码======================
int compute(const char* exp){
	Stack* stack = Stack_Create();
	int ret = 0;
	int i = 0;
	
	while (exp[i] != '\0') {
		if ( isNumber(exp[i]) ){
			Stack_Push(stack, (void*)value(exp[i]));
		} else if (isOperator(exp[i])) {
			int right = (int)Stack_Pop(stack);
			int left = (int)Stack_Pop(stack);
			int result = express(left, right, exp[i]);
			Stack_Push(stack, (void*)result);
		} else {
			printf("Invalid Expression");
			break;
		}
		i++;
	}
	
	if (Stack_Size(stack) == 1 && exp[i] == '\0') {
		ret = (int)Stack_Pop(stack);
	} else {
		printf("Invalid Expression");
	}
	Stack_Destroy(stack);
	return ret;
}
int main(){
	compute("831-5*+");
}

如果将8+(3-1)*5这样的表达式转换为二叉树模型，则对二叉树进行中序遍历时生成中缀表达式，而后续遍历则生成后缀表达式

队列=================================
操作：销毁 清空 入队 出队 获取队头元素 获取队列长度
seqqueue.h=========
#ifndef _MY_SEQQUEUE_H_
#define _MY_SEQQUEUE_H_
typedef void SeqQueue;

SeqQueue* SeqQueue_Create(int capacity);

void SeqQueue_Destroy(SeqQueue* queue);

void SeqQueue_Clear(SeqQueue* queue);

int SeqQueue_Append(SeqQueue* queue, void* item);

void* SeqQueue_Retrieve(SeqQueue* queue);

void* SeqQueue_Header(SeqQueue* queue);

int SeqQueue_Length(SeqQueue* queue);

int SeqQueue_Capacity(SeqQueue* queue);

#endif

seqqueue.c=============
#include "seqqueue.h"
#include "seqlist.h"
// 队列也是一种特殊的线性表
SeqQueue* SeqQueue_Create(int capacity){
	return SeqList_Create(capacity);
}

void SeqQueue_Destroy(SeqQueue* queue){
	return SeqList_Destroy(queue);
}

void SeqQueue_Clear(SeqQueue* queue){
	return SeqList_Clear(queue);
}
// 入队
int SeqQueue_Append(SeqQueue* queue, void* item){
	return SeqList_Insert(queue, item, SeqList_Length(queue));
}
// 出队
void* SeqQueue_Retrieve(SeqQueue* queue){
	return SeqList_Delete(queue, 0);
}

void* SeqQueue_Header(SeqQueue* queue){
	return SeqList_Get(queue, 0);
}

int SeqQueue_Length(SeqQueue* queue){
	return SeqList_Length(queue);
}

int SeqQueue_Capacity(SeqQueue* queue){
	return SeqList_Capacity(queue);
}

测试.c=============
void main(){
	int i;
	int a[10];
	SeqQueue* queue = NULL;
	queue = SeqQueue_Create(10);
	
	if (queue == NULL) {
		return;
	}
	
	for ( i = 0; i < 5; i++) {
		a[i] = i + 1;
		SeqQueue_Append(queue, &a[i]);
	}
	
	printf(SeqQueue_Length(queue));
	printf(*((int*)SeqQueue_Header(queue))); // 栈顶元素
	printf(SeqQueue_Capacity(queue));
	
	while (SeqQueue_Length(queue) > 0) {
		int tmp = *((int*)SeqQueue_Retrieve(queue));
		printf(tmp);
	}
	SeqQueue_Destroy(queue);
}

队列链式存储===========================
linkqueue.h=========
#ifndef _MY_LINKQUEUE_H_
#define _MY_LINKQUEUE_H_
typedef void LinkQueue;

LinkQueue* LinkQueue_Create(int capacity);

void LinkQueue_Destroy(LinkQueue* queue);

void LinkQueue_Clear(LinkQueue* queue);

int LinkQueue_Append(LinkQueue* queue, void* item);

void* LinkQueue_Retrieve(LinkQueue* queue);

void* LinkQueue_Header(LinkQueue* queue);

int LinkQueue_Length(LinkQueue* queue);

#endif

seqqueue.c=============
#include "linkqueue.h"
#include "linklist.h"
// 队列业务节点数据结构
typedef struct _tag_LinkQueueNode{
	LinkListNode node;
	void* item;
}TLinkQueueNode;
LinkQueue* LinkQueue_Create(){
	return LinkList_Create();
}
// 涉及节点的内存管理
void LinkQueue_Destroy(LinkQueue* queue){
	LinkQueue_Clear(queue);
	return LinkList_Destroy(queue);
}
// 清空队列需要显式的把队列中所有节点的内存释放
void LinkQueue_Clear(LinkQueue* queue){
	while(LinkQueue_Length(queue) > 0){
		LinkQueue_Retrieve(queue);
	}
	LinkList_Clear(queue);
}

int LinkQueue_Append(LinkQueue* queue, void* item){
	TLinkQueueNode* tmp = NULL;
	int ret = 0;
	tmp = (TLinkQueueNode*)malloc(sizeof(TLinkQueueNode));
	if (tmp == NULL) {
		ret = -1;
	}
	memset(tmp, 0, sizeof(TLinkQueueNode));
	tmp -> node.next = NULL;
	tmp -> item = item;
	// 需要把队列的业务节点转化成链表的业务节点
	ret = LinkList_Insert(queue, (LinkListNode*)tmp, LinkList_Length(queue));
	if (ret != 0) {
		if (tmp != NULL) {
			free(tmp);
		}
		return ret;
	}
	return 0;
}

void* LinkQueue_Retrieve(LinkQueue* queue){
	TLinkQueueNode* tmp = NULL;
	void* ret = NULL;
	
	tmp = (TLinkListNode*)LinkList_Delete(queue, 0);
	if (tmp == NULL) {
		return NULL;
	}
	ret = tmp -> item;
	if (tmp != NULL) {
		free(tmp);
	}
	return ret;
}

void* LinkQueue_Header(LinkQueue* queue){
	TLinkQueueNode* tmp = NULL;
	void* ret = NULL;
	
	tmp = (TLinkQueueNode*)LinkList_Get(queue, 0);
	
	if (tmp == NULL) {
		return NULL;
	}

	return tmp -> item;
}

int LinkQueue_Length(LinkQueue* queue){
	return LinkList_Length(queue);
}

// 测试.c==========
void main(){
	int i;
	int a[10];
	LinkQueue* queue = NULL;
	queue = LinkQueue_Create();
	if (queue == NULL) {
		return;
	}
	for (i = 0; i < 5; i++) {
		a[i] = i + 1;
		LinkQueue_Append(&a[i]);
	}
	
	printf(LinkQueue_Length(queue));
	printf(*((int*)LinkQueue_Header(queue)));
	
	while(LinkQueue_Length(queue) > 0) {
		int tmp;
		tmp = *（(int*)LinkQueue_Retrieve(queue));
		printf(tmp);
	}
	
	LinkQueue_Destroy(queue);
}

树====================================
完全二叉树：
1、第k-1层和满二叉树一样
2、最后一层：叶子节点尽量靠左

具有n个节点的完全二叉树的深度为以2为底n的对数向下取整，再加1

对完全二叉树，从上到下，从左到右编号，则编号为i的节点，左孩子的编号为2i，有孩子的编号为2i + 1，双亲的编号为i / 2(根除外)，这是二叉树顺序存储的原理，但是遇到不全的树时需要将其补全才可以，所以树通常不会顺序存储

二叉链表示法==========================
typedef struct BiTNode{
	int data;
	struct BiTNode* lchild, rchild;
}BiTNode, *BiTree;
void main(){
	BiTNode t1, t2, t3, t4, t5;
	
	t1.data = 1;
	t2.data = 2;
	t3.data = 3;
	t4.data = 4;
	t5.data = 5;
	
	t1.lchild = &t2;
	t1.rchild = &t3;
	t2.lchild = &t4;
	t3.lchild = &t5;
	
	// malloc使用堆内存===============
	BiTNode* p1, *p2, *p3, *p4, *p5;
	p1 = (BiTNode*)malloc(sizeof(BiTNode));
	p2 = (BiTNode*)malloc(sizeof(BiTNode));
	p3 = (BiTNode*)malloc(sizeof(BiTNode));
	p4 = (BiTNode*)malloc(sizeof(BiTNode));
	p5 = (BiTNode*)malloc(sizeof(BiTNode));
	
	p1 -> data = 1;
	p2 -> data = 2;
	p3 -> data = 3;
	p4 -> data = 4;
	p5 -> data = 5;
	
	p1 -> lchild = p2;
	p1 -> rchild = p3;
	p2 -> lchild = p4;
	p3 -> lchild = p5;
}

三叉链表示法(用的较少)==========================

双亲链表表示法
#define MAX_TREE_SIZE 100
typedef struct BPTNode{
	int data;
	int parentPosition;
	char LRTag; // 左右孩子标志域 当前节点如果是parentPosition的左节点就表示为1，右节点就表示为2
}BPTNode;
typedef struct BPTree{
	BPTNode nodes[100];
	int num_node;
	int root;
}BPTree;

不管哪种遍历，都是相对根来说的
先序遍历：先遍历根 再遍历左子树 再遍历右子树 遍历到最深的根左子树时如果有子节点，则要针对该子树进行相同顺序的遍历，即递归遍历
中序遍历：先遍历左子树 再遍历根 再遍历右子树
后序遍历：先遍历左子树 再遍历右子树 再遍历根

树的遍历=======================
void preOrder(BiTNode* root){
	if (root == NULL) {
		return;
	}
	// 遍历根节点
	printf(root -> data);
	// 再遍历左子树
	preOrder(root -> lchild);
	// 再遍历右子树
	preOrder(root -> rchild);
}
void inOrder(BiTNode* root){
	if (root == NULL) {
		return;
	}
	// 遍历左子树
	inOrder(root -> lchild);
	// 再遍历根节点
	printf(root -> data);
	// 再遍历右子树
	inOrder(root -> rchild);
	
}
void postOrder(BiTNode* root){
	if (root == NULL) {
		return;
	}
	// 遍历左子树
	postOrder(root -> lchild);
	// 再遍历右子树
	postOrder(root -> rchild)
	// 再遍历根节点
	printf(root -> data);
}
void main(){
	BiTNode t1, t2, t3, t4, t5;
	memset(&t1, 0, sizeof(BiTNode));
	memset(&t2, 0, sizeof(BiTNode));
	memset(&t3, 0, sizeof(BiTNode));
	memset(&t4, 0, sizeof(BiTNode));
	memset(&t5, 0, sizeof(BiTNode));
	
	t1.data = 1;
	t2.data = 2;
	t3.data = 3;
	t4.data = 4;
	t5.data = 5;
	
	t1.lchild = &t2;
	t1.rchild = &t3;
	t2.lchild = &t4;
	t3.lchild = &t5;
}

// 树叶子节点的计算
int sum = 0;
void countLeaf(BiTNode* T){
	if (T != NULL) {
		if (T -> lchild == NULL && T -> rchild == NULL ) {
			sum++;
		}
		if (T -> lchild) {
			countLeaf(T -> lchild);
		}
		if (T -> rchild) {
			countLeaf(T -> rchild);
		}
	}
}
// 上面这种计算叶子节点的方法需要定义一个全局变量，并不太好，在多线程的场合会存在资源竞争问题
void countLeaf3(BiTNode* T, int* sum){
	if (T != NULL) {
		if (T -> lchild == NULL && T -> rchild == NULL ) {
			(*sum)++; // 注意不可以写成*sum++，这样写就成了sum指针本身自增
		}
		if (T -> lchild) {
			countLeaf(T -> lchild);
		}
		if (T -> rchild) {
			countLeaf(T -> rchild);
		}
	}
}

// 求树的深度 思路：求左右两边的深度再加1(根节点)，如果左右子树还有子树，则递归求
int Depth(BiTNode* T){
	int depthLeft = 0;
	int depthRight = 0;
	int deptval = 0;
	
	if ( T == NULL) {
		deptval = 0;
		return deptval;
	}
	
	depthLeft = Depth(T -> lchild);
	
	depthRight = Depth(T -> rchild);
	
	return deptval = 1 + depthLeft > depthRight ? depthLeft : depthRight;
}

// 拷贝一棵树
BiTNode* CopyTree(BiTNode* T){
	BiTNode* newNode = NULL;
	BiTNode* leftNode = NULL;
	BiTNode* rightNode = NULL;
	
	if ( T -> NULL ) {
		return NULL;
	}
	
	if ( T -> lchild != NULL ) {
		leftNode = CopyTree(T -> lchild);
	} else {
		leftNode = NULL;
	}
	
	if ( T -> rchild != NULL ) {
		rightNode = CopyTree(T -> rchild);
	} else {
		rightNode = NULL;
	}
	
	newNode = (BiTNode*)malloc(sizeof(BiTNode));
	
	if (newNode == NULL) {
		return NULL;
	}
	newNode -> lchild = leftNode;
	newNode -> rchild = rightNode;
	newNode -> data = T -> data;
	
	return NULL;
}

// 树的非递归遍历(中序遍历) 需要借助栈，遍历的过程中会先遇到根节点，但是不会访问根节点，而是先判断根节点有没有左右子树，然后左右子树遍历完了之后再回过头来访问根节点，因此第一次遇到根节点的时候不具体访问而是回过头来再访问很明显是栈模型
// 算法具体内容：
步骤1：
如果节点有左子树，该节点入栈，将遍历指针指向左子树
如果节点没有左子树，访问该节点

步骤2：
如果节点有右子树，重复步骤1
如果节点没有右子树，根据栈顶指示回退，访问栈顶元素，并访问右子树，重复步骤1

如果栈为空，表示遍历结束
#include "stack"
BiTNode* goLeft(BiTNode* T, stack<BiTNode*> &s){
	if ( T == NULL ) {
		return NULL;
	}
	while(T -> lchild) {
		s.push(T);
		T = T -> lchild;
	}
	return T;
}
void inOrder2(BiTNode* T){
	BiTNode* t = NULL;
	stack<BiTNode*> s;
	// 执行节点入栈，并将遍历指针指向左子树
	t = goLeft(T, s);
	
	while(t) {
		printf(t.data);
		
		// 如果t有右子树
		if (t -> rchild != NULL) {
			// 右子树中序遍历的起点
			t = goLeft(t -> rchild, s);
		} else if (!s.empty()) {
			// 如果t没有右子树，根据栈顶指示回退
			t = s.top();
			s.pop();
		} else {
			// 如果t没有右子树 并且栈为空
			t = NULL;
		}
	}
}
// 利用我们自己实现的栈
BiTNode* goLeft(BiTNode* T, stack<BiTNode*> &s){
	if ( T == NULL ) {
		return NULL;
	}
	while(T -> lchild) {
		LinkStack_Push(s, (void*)T);
		T = T -> lchild;
	}
	return T;
}
void inOrder2(BiTNode* T, LinkStack *s){
	BiTNode* t = NULL;
	LinkStack *s = LinkStack_Create();
	t = goLeft(T, s);
	while(t){
		printf(t -> data);
		if (t -> rchild != NULL) {
			// 右子树中序遍历的起点
			t = goLeft(t -> rchild, s);
		} else if (LinkStack_Size(s) > 0) {
			// 如果t没有右子树，根据栈顶指示回退
			// t = s.top();
			// s.pop();
			t = (BiTNode*)LinkStack_Pop(s);
		} else {
			// 如果t没有右子树 并且栈为空
			t = NULL;
		}
	}
}

通过中序遍历结果和先序遍历结果可以确定一棵树
通过中序遍历结果和后序遍历结果可以确定一棵树
通过先序遍历结果和后序遍历结果不可以确定一棵树

先序遍历结果：ADEBCF
中序遍历结果：DEACFB
通过以上结果确定树的结构
1、通过先序遍历找到根节点A，再通过A在中序遍历的位置找出左子树、右子树
2、在A的左子树中，找左子树的根节点（在先序中找），转步骤1
3、在A的右子树中，找右子树的根节点（在先序中找），转步骤1

seqlist类模板框架搭建=============================
SeqList.h========
template <typename T>
class SeqList{
	public:
		SeqList(int Capacity);
		~SeqList(void);
		int getLen();
		int getCap(int cap);
		int insert(T &t, int pos);
		int get(int pos, T &t);
		int del(int pos, T &t);
	private:
		int len;
		int capacity;
		T *pArray;
}
SeqList.cpp========
#include "SeqList.h"

template<typename T>
SeqList<T>::SeqList(int Capacity){
	pArray = new T[Capacity];
	this -> capacity = Capacity;
	this -> len = 0;
}

template<typename T>
SeqList<T>::~SeqList(void){
	delete [] pArray;
	pArray = NULL;
	len = 0;
	capacity = 0;
}

template<typename T>
int SeqList<T>::getLen(){
	return this -> len;
}

template<typename T>
int SeqList<T>::getCap(int cap){
	return capacity;
}

template<typename T>
int SeqList<T>::insert(T &t, int pos){
	int i = 0;
	
	// if ( t == NULL || pos < 0) {
	if (pos < 0) {
		return -1;
	}
	
	for ( i = len; i > pos; i--) {
		pArray[i] = pArray[i - 1];
	}
	
	pArray[i] = t; // STL元素保存时是通过复制的机制实现的
	this -> len++;
	return 0;
}

template<typename T>
int SeqList<T>::get(int pos, T &t){
	int i = 0;
	
	//if ( t == NULL || pos < 0) {
	if (pos < 0) {
		return -1;
	}
	
	t = pArray[pos];
	return 0;
}

template<typename T>
int SeqList<T>::del(int pos, T &t){
	int i = 0;
	
	if (pos < 0) {
		return -1;
	}
	
	t = pArray[pos];
	
	for ( i = pos + 1; i < this -> len; i++){
		pArray[i - 1] = pArray[i];
	}
	len--;
	return 0;
}
main.cpp========
#include "SeqList.cpp" // 如果引.h就会导致重复引入的错误
void main_play(){
	Teacher t1, t2, t3, tmp;
	SeqList<Teacher> list(10);
	list.insert(t1, 0); // 将t1插入到1号位置
	list.insert(t2, 0);
	list.insert(t3, 0);
	
	for (int i = 0; i < list.getLen(); i++) {
		// get方法的定义那边tmp是个引用
		list.get(i, tmp);
		cout << tmp.age;
	}
	
	while (list.getLen() > 0) {
		list.del(0, tmp);
		cout << tmp.age;
	}
	
	// 往容器里存指针======================
	Teacher t1, t2, t3, tmp;
	Teacher *p1, *p2, *p3, *tmp;
	
	p1 = &t1;
	p2 = &t2;
	p3 = &t3;
	
	SeqList<Teacher*> list[10];
	list.insert(p1, 0);
	list.insert(p2, 0);
	list.insert(p3, 0);
	
	for (int i = 0; i < list.getLen(); i++) {
		list.get(i, tmp);
		cout << tmp -> age;
	}
	
	while (list.getLen() > 0) {
		list.del(0, tmp);
		cout << tmp -> age;
	}
}
void main(){
	// 该函数结束的时候就会执行Teacher的析构函数
	main_play();
}

树的创建===================================================================
#创建树（思想：补充空位置）
BiTNode *createTree(){
	BiTNode *node = NULL;
	BiTNode *pL = NULL;
	BiTNode *pR = NULL;
	char h;
	scanf("%c", &h);
	
	if (h == '#') {
		return NULL;
	} else {
		node = (BiTNode*)malloc(sizeof(BiTNode));
		if (tmp == NULL) {
			return NULL;
		}
		memset(node, 0, sizeof(BiTNode));
		node -> data = h;
		node -> lchild = createTree();
		node -> rchild = createTree();
		return node;
	}
}
void main(){
	BiTNode *p = NULL;
	p = createTree();
}
================================
// 创建树时输入的序列为ABDH#K###E##CFI###G#J##（先序遍历结果） 画出树的形状

// 中序和先序组合创建树

// 树的非递归遍历



